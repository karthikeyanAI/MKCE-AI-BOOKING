"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOutpostArnablesMiddleawareOptions = exports.parseOutpostArnablesMiddleaware = void 0;
const middleware_bucket_endpoint_1 = require("@aws-sdk/middleware-bucket-endpoint");
const util_arn_parser_1 = require("@aws-sdk/util-arn-parser");
const util_endpoints_1 = require("@aws-sdk/util-endpoints");
const constants_1 = require("../constants");
const parseOutpostArnablesMiddleaware = (options) => (next, context) => async (args) => {
    var _a, _b, _c, _d;
    const { input } = args;
    const parameter = input.Name && (0, util_arn_parser_1.validate)(input.Name) ? "Name" : input.Bucket && (0, util_arn_parser_1.validate)(input.Bucket) ? "Bucket" : undefined;
    if (!parameter)
        return next(args);
    const clientRegion = await options.region();
    const useArnRegion = await options.useArnRegion();
    const useFipsEndpoint = await options.useFipsEndpoint();
    const useDualstackEndpoint = await options.useDualstackEndpoint();
    const baseRegion = clientRegion;
    let clientPartition;
    let signingRegion;
    if (options.regionInfoProvider) {
        ({ partition: clientPartition, signingRegion = baseRegion } = (await options.regionInfoProvider(baseRegion, {
            useFipsEndpoint,
            useDualstackEndpoint,
        })));
    }
    else {
        signingRegion = ((_d = (_c = (_b = (_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.authSchemes) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.signingRegion) || baseRegion;
        clientPartition = (0, util_endpoints_1.partition)(signingRegion).name;
    }
    const validatorOptions = {
        useFipsEndpoint,
        useDualstackEndpoint,
        clientRegion,
        clientPartition,
        signingRegion,
        useArnRegion,
    };
    let arn;
    if (parameter === "Name") {
        arn = (0, util_arn_parser_1.parse)(input.Name);
        validateOutpostsArn(arn, validatorOptions);
        const { outpostId, accesspointName } = parseOutpostsAccessPointArnResource(arn.resource);
        input.Name = accesspointName;
        context[constants_1.CONTEXT_OUTPOST_ID] = outpostId;
    }
    else {
        arn = (0, util_arn_parser_1.parse)(input.Bucket);
        validateOutpostsArn(arn, validatorOptions);
        const { outpostId, bucketName } = parseOutpostBucketArnResource(arn.resource);
        input.Bucket = bucketName;
        context[constants_1.CONTEXT_OUTPOST_ID] = outpostId;
    }
    context[constants_1.CONTEXT_SIGNING_SERVICE] = arn.service;
    context[constants_1.CONTEXT_SIGNING_REGION] = useArnRegion ? arn.region : signingRegion;
    if (!input.AccountId) {
        input.AccountId = arn.accountId;
    }
    else if (input.AccountId !== arn.accountId) {
        throw new Error(`AccountId is incompatible with account id inferred from ${parameter}`);
    }
    if (useArnRegion)
        context[constants_1.CONTEXT_ARN_REGION] = arn.region;
    return next(args);
};
exports.parseOutpostArnablesMiddleaware = parseOutpostArnablesMiddleaware;
exports.parseOutpostArnablesMiddleawareOptions = {
    step: "initialize",
    tags: ["CONVERT_ARN", "OUTPOST_BUCKET_ARN", "OUTPOST_ACCESS_POINT_ARN", "OUTPOST"],
    name: "parseOutpostArnablesMiddleaware",
};
const validateOutpostsArn = (arn, { clientRegion, signingRegion, clientPartition, useArnRegion, useFipsEndpoint, useDualstackEndpoint, }) => {
    const { service, partition, accountId, region } = arn;
    (0, middleware_bucket_endpoint_1.validateOutpostService)(service);
    (0, middleware_bucket_endpoint_1.validatePartition)(partition, { clientPartition });
    (0, middleware_bucket_endpoint_1.validateAccountId)(accountId);
    (0, middleware_bucket_endpoint_1.validateRegion)(region, {
        useArnRegion,
        clientRegion,
        clientSigningRegion: signingRegion,
        useFipsEndpoint,
        allowFipsRegion: true,
    });
    (0, middleware_bucket_endpoint_1.validateNoDualstack)(useDualstackEndpoint);
};
const parseOutpostsAccessPointArnResource = (resource) => {
    const { outpostId, accesspointName } = (0, middleware_bucket_endpoint_1.getArnResources)(resource);
    if (!outpostId) {
        throw new Error("ARN resource should begin with 'outpost'");
    }
    return {
        outpostId,
        accesspointName,
    };
};
const parseOutpostBucketArnResource = (resource) => {
    const delimiter = resource.includes(":") ? ":" : "/";
    const [resourceType, ...rest] = resource.split(delimiter);
    if (resourceType === "outpost") {
        if (!rest[0] || rest[1] !== "bucket" || !rest[2] || rest.length !== 3) {
            throw new Error(`Outpost Bucket ARN should have resource outpost${delimiter}{outpostId}${delimiter}bucket${delimiter}{bucketName}`);
        }
        const [outpostId, _, bucketName] = rest;
        return { outpostId, bucketName };
    }
    else {
        throw new Error(`ARN resource should begin with 'outpost${delimiter}'`);
    }
};
