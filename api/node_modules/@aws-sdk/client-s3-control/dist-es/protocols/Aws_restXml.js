import { XmlNode as __XmlNode, XmlText as __XmlText } from "@aws-sdk/xml-builder";
import { HttpRequest as __HttpRequest, isValidHostname as __isValidHostname, } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, expectUnion as __expectUnion, getArrayIfSingleItem as __getArrayIfSingleItem, getValueFromTextNode as __getValueFromTextNode, map, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, resolvedPath as __resolvedPath, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { XMLParser } from "fast-xml-parser";
import { v4 as generateIdempotencyToken } from "uuid";
import { BadRequestException, BucketAlreadyExists, BucketAlreadyOwnedByYou, IdempotencyException, InternalServiceException, InvalidNextTokenException, InvalidRequestException, JobManifestGenerator, NoSuchPublicAccessBlockConfiguration, NotFoundException, ObjectLambdaContentTransformation, TooManyRequestsException, } from "../models/models_0";
import { JobStatusException, TooManyTagsException, } from "../models/models_1";
import { S3ControlServiceException as __BaseException } from "../models/S3ControlServiceException";
export const se_AssociateAccessGrantsIdentityCenterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/identitycenter";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("AssociateAccessGrantsIdentityCenterRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.IdentityCenterArn !== undefined) {
        const node = __XmlNode.of("IdentityCenterArn", input.IdentityCenterArn).withName("IdentityCenterArn");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateAccessGrantCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstance/grant";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateAccessGrantRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.AccessGrantsLocationConfiguration !== undefined) {
        const node = se_AccessGrantsLocationConfiguration(input.AccessGrantsLocationConfiguration, context).withName("AccessGrantsLocationConfiguration");
        bodyNode.addChildNode(node);
    }
    if (input.AccessGrantsLocationId !== undefined) {
        const node = __XmlNode
            .of("AccessGrantsLocationId", input.AccessGrantsLocationId)
            .withName("AccessGrantsLocationId");
        bodyNode.addChildNode(node);
    }
    if (input.ApplicationArn !== undefined) {
        const node = __XmlNode.of("IdentityCenterApplicationArn", input.ApplicationArn).withName("ApplicationArn");
        bodyNode.addChildNode(node);
    }
    if (input.Grantee !== undefined) {
        const node = se_Grantee(input.Grantee, context).withName("Grantee");
        bodyNode.addChildNode(node);
    }
    if (input.Permission !== undefined) {
        const node = __XmlNode.of("Permission", input.Permission).withName("Permission");
        bodyNode.addChildNode(node);
    }
    if (input.S3PrefixType !== undefined) {
        const node = __XmlNode.of("S3PrefixType", input.S3PrefixType).withName("S3PrefixType");
        bodyNode.addChildNode(node);
    }
    if (input.Tags !== undefined) {
        const nodes = se_TagList(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateAccessGrantsInstanceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstance";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateAccessGrantsInstanceRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.IdentityCenterArn !== undefined) {
        const node = __XmlNode.of("IdentityCenterArn", input.IdentityCenterArn).withName("IdentityCenterArn");
        bodyNode.addChildNode(node);
    }
    if (input.Tags !== undefined) {
        const nodes = se_TagList(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateAccessGrantsLocationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstance/location";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateAccessGrantsLocationRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.IAMRoleArn !== undefined) {
        const node = __XmlNode.of("IAMRoleArn", input.IAMRoleArn).withName("IAMRoleArn");
        bodyNode.addChildNode(node);
    }
    if (input.LocationScope !== undefined) {
        const node = __XmlNode.of("S3Prefix", input.LocationScope).withName("LocationScope");
        bodyNode.addChildNode(node);
    }
    if (input.Tags !== undefined) {
        const nodes = se_TagList(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateAccessPointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accesspoint/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateAccessPointRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Bucket !== undefined) {
        const node = __XmlNode.of("BucketName", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    if (input.BucketAccountId !== undefined) {
        const node = __XmlNode.of("AccountId", input.BucketAccountId).withName("BucketAccountId");
        bodyNode.addChildNode(node);
    }
    if (input.PublicAccessBlockConfiguration !== undefined) {
        const node = se_PublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, context).withName("PublicAccessBlockConfiguration");
        bodyNode.addChildNode(node);
    }
    if (input.VpcConfiguration !== undefined) {
        const node = se_VpcConfiguration(input.VpcConfiguration, context).withName("VpcConfiguration");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateAccessPointForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateAccessPointForObjectLambdaRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Configuration !== undefined) {
        const node = se_ObjectLambdaConfiguration(input.Configuration, context).withName("Configuration");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateBucketCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-acl": input.ACL,
        "x-amz-grant-full-control": input.GrantFullControl,
        "x-amz-grant-read": input.GrantRead,
        "x-amz-grant-read-acp": input.GrantReadACP,
        "x-amz-grant-write": input.GrantWrite,
        "x-amz-grant-write-acp": input.GrantWriteACP,
        "x-amz-bucket-object-lock-enabled": [
            () => isSerializableHeaderValue(input.ObjectLockEnabledForBucket),
            () => input.ObjectLockEnabledForBucket.toString(),
        ],
        "x-amz-outpost-id": input.OutpostId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let contents;
    if (input.CreateBucketConfiguration !== undefined) {
        contents = se_CreateBucketConfiguration(input.CreateBucketConfiguration, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
        body += contents.toString();
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/jobs";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateJobRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.ClientRequestToken === undefined) {
        input.ClientRequestToken = generateIdempotencyToken();
    }
    if (input.ClientRequestToken !== undefined) {
        const node = __XmlNode.of("NonEmptyMaxLength64String", input.ClientRequestToken).withName("ClientRequestToken");
        bodyNode.addChildNode(node);
    }
    if (input.ConfirmationRequired !== undefined) {
        const node = __XmlNode
            .of("ConfirmationRequired", String(input.ConfirmationRequired))
            .withName("ConfirmationRequired");
        bodyNode.addChildNode(node);
    }
    if (input.Description !== undefined) {
        const node = __XmlNode.of("NonEmptyMaxLength256String", input.Description).withName("Description");
        bodyNode.addChildNode(node);
    }
    if (input.Manifest !== undefined) {
        const node = se_JobManifest(input.Manifest, context).withName("Manifest");
        bodyNode.addChildNode(node);
    }
    if (input.ManifestGenerator !== undefined) {
        const node = se_JobManifestGenerator(input.ManifestGenerator, context).withName("ManifestGenerator");
        bodyNode.addChildNode(node);
    }
    if (input.Operation !== undefined) {
        const node = se_JobOperation(input.Operation, context).withName("Operation");
        bodyNode.addChildNode(node);
    }
    if (input.Priority !== undefined) {
        const node = __XmlNode.of("JobPriority", String(input.Priority)).withName("Priority");
        bodyNode.addChildNode(node);
    }
    if (input.Report !== undefined) {
        const node = se_JobReport(input.Report, context).withName("Report");
        bodyNode.addChildNode(node);
    }
    if (input.RoleArn !== undefined) {
        const node = __XmlNode.of("IAMRoleArn", input.RoleArn).withName("RoleArn");
        bodyNode.addChildNode(node);
    }
    if (input.Tags !== undefined) {
        const nodes = se_S3TagSet(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateMultiRegionAccessPointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/async-requests/mrap/create";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateMultiRegionAccessPointRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.ClientToken === undefined) {
        input.ClientToken = generateIdempotencyToken();
    }
    if (input.ClientToken !== undefined) {
        const node = __XmlNode.of("MultiRegionAccessPointClientToken", input.ClientToken).withName("ClientToken");
        bodyNode.addChildNode(node);
    }
    if (input.Details !== undefined) {
        const node = se_CreateMultiRegionAccessPointInput(input.Details, context).withName("Details");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_CreateStorageLensGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelensgroup";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("CreateStorageLensGroupRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.StorageLensGroup !== undefined) {
        const node = se_StorageLensGroup(input.StorageLensGroup, context).withName("StorageLensGroup");
        bodyNode.addChildNode(node);
    }
    if (input.Tags !== undefined) {
        const nodes = se_TagList(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessGrantCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/grant/{AccessGrantId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "AccessGrantId", () => input.AccessGrantId, "{AccessGrantId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessGrantsInstanceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstance";
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessGrantsInstanceResourcePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/resourcepolicy";
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessGrantsLocationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/location/{AccessGrantsLocationId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "AccessGrantsLocationId", () => input.AccessGrantsLocationId, "{AccessGrantsLocationId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessPointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accesspoint/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessPointForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessPointPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accesspoint/{Name}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteAccessPointPolicyForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteBucketCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteBucketLifecycleConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/bucket/{Bucket}/lifecycleconfiguration";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteBucketPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteBucketReplicationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/replication";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteBucketTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteJobTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/jobs/{JobId}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "JobId", () => input.JobId, "{JobId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteMultiRegionAccessPointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/async-requests/mrap/delete";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("DeleteMultiRegionAccessPointRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.ClientToken === undefined) {
        input.ClientToken = generateIdempotencyToken();
    }
    if (input.ClientToken !== undefined) {
        const node = __XmlNode.of("MultiRegionAccessPointClientToken", input.ClientToken).withName("ClientToken");
        bodyNode.addChildNode(node);
    }
    if (input.Details !== undefined) {
        const node = se_DeleteMultiRegionAccessPointInput(input.Details, context).withName("Details");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeletePublicAccessBlockCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/configuration/publicAccessBlock";
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteStorageLensConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelens/{ConfigId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ConfigId", () => input.ConfigId, "{ConfigId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteStorageLensConfigurationTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelens/{ConfigId}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "ConfigId", () => input.ConfigId, "{ConfigId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DeleteStorageLensGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelensgroup/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/jobs/{JobId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "JobId", () => input.JobId, "{JobId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DescribeMultiRegionAccessPointOperationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/async-requests/mrap/{RequestTokenARN+}";
    resolvedPath = __resolvedPath(resolvedPath, input, "RequestTokenARN", () => input.RequestTokenARN, "{RequestTokenARN+}", true);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_DissociateAccessGrantsIdentityCenterCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/identitycenter";
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessGrantCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/grant/{AccessGrantId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "AccessGrantId", () => input.AccessGrantId, "{AccessGrantId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessGrantsInstanceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstance";
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessGrantsInstanceForPrefixCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstance/prefix";
    const query = map({
        s3prefix: [, __expectNonNull(input.S3Prefix, `S3Prefix`)],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetAccessGrantsInstanceResourcePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/resourcepolicy";
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessGrantsLocationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/location/{AccessGrantsLocationId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "AccessGrantsLocationId", () => input.AccessGrantsLocationId, "{AccessGrantsLocationId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessPointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accesspoint/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessPointConfigurationForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}/configuration";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessPointForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessPointPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accesspoint/{Name}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessPointPolicyForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessPointPolicyStatusCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspoint/{Name}/policyStatus";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetAccessPointPolicyStatusForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}/policyStatus";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetBucketCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetBucketLifecycleConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/bucket/{Bucket}/lifecycleconfiguration";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetBucketPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetBucketReplicationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/replication";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetBucketTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetBucketVersioningCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/versioning";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetDataAccessCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/dataaccess";
    const query = map({
        target: [, __expectNonNull(input.Target, `Target`)],
        permission: [, __expectNonNull(input.Permission, `Permission`)],
        durationSeconds: [() => input.DurationSeconds !== void 0, () => input.DurationSeconds.toString()],
        privilege: [, input.Privilege],
        targetType: [, input.TargetType],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_GetJobTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/jobs/{JobId}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "JobId", () => input.JobId, "{JobId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetMultiRegionAccessPointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/mrap/instances/{Name+}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name+}", true);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetMultiRegionAccessPointPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/mrap/instances/{Name+}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name+}", true);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetMultiRegionAccessPointPolicyStatusCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/mrap/instances/{Name+}/policystatus";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name+}", true);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetMultiRegionAccessPointRoutesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/mrap/instances/{Mrap+}/routes";
    resolvedPath = __resolvedPath(resolvedPath, input, "Mrap", () => input.Mrap, "{Mrap+}", true);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetPublicAccessBlockCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/configuration/publicAccessBlock";
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetStorageLensConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelens/{ConfigId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ConfigId", () => input.ConfigId, "{ConfigId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetStorageLensConfigurationTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelens/{ConfigId}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "ConfigId", () => input.ConfigId, "{ConfigId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetStorageLensGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelensgroup/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_ListAccessGrantsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstance/grants";
    const query = map({
        nextToken: [, input.NextToken],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        granteetype: [, input.GranteeType],
        granteeidentifier: [, input.GranteeIdentifier],
        permission: [, input.Permission],
        grantscope: [, input.GrantScope],
        application_arn: [, input.ApplicationArn],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListAccessGrantsInstancesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstances";
    const query = map({
        nextToken: [, input.NextToken],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListAccessGrantsLocationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accessgrantsinstance/locations";
    const query = map({
        nextToken: [, input.NextToken],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        locationscope: [, input.LocationScope],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListAccessPointsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accesspoint";
    const query = map({
        bucket: [, input.Bucket],
        nextToken: [, input.NextToken],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListAccessPointsForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accesspointforobjectlambda";
    const query = map({
        nextToken: [, input.NextToken],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListJobsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/jobs";
    const query = map({
        jobStatuses: [() => input.JobStatuses !== void 0, () => (input.JobStatuses || []).map((_entry) => _entry)],
        nextToken: [, input.NextToken],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListMultiRegionAccessPointsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/mrap/instances";
    const query = map({
        nextToken: [, input.NextToken],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListRegionalBucketsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
        "x-amz-outpost-id": input.OutpostId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket";
    const query = map({
        nextToken: [, input.NextToken],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListStorageLensConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelens";
    const query = map({
        nextToken: [, input.NextToken],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListStorageLensGroupsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelensgroup";
    const query = map({
        nextToken: [, input.NextToken],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/tags/{ResourceArn+}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn+}", true);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutAccessGrantsInstanceResourcePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/resourcepolicy";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutAccessGrantsInstanceResourcePolicyRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Organization !== undefined) {
        const node = __XmlNode.of("Organization", input.Organization).withName("Organization");
        bodyNode.addChildNode(node);
    }
    if (input.Policy !== undefined) {
        const node = __XmlNode.of("PolicyDocument", input.Policy).withName("Policy");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutAccessPointConfigurationForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}/configuration";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutAccessPointConfigurationForObjectLambdaRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Configuration !== undefined) {
        const node = se_ObjectLambdaConfiguration(input.Configuration, context).withName("Configuration");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutAccessPointPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/accesspoint/{Name}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutAccessPointPolicyRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Policy !== undefined) {
        const node = __XmlNode.of("Policy", input.Policy).withName("Policy");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutAccessPointPolicyForObjectLambdaCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accesspointforobjectlambda/{Name}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutAccessPointPolicyForObjectLambdaRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Policy !== undefined) {
        const node = __XmlNode.of("ObjectLambdaPolicy", input.Policy).withName("Policy");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutBucketLifecycleConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/bucket/{Bucket}/lifecycleconfiguration";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let contents;
    if (input.LifecycleConfiguration !== undefined) {
        contents = se_LifecycleConfiguration(input.LifecycleConfiguration, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
        body += contents.toString();
    }
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutBucketPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
        "x-amz-confirm-remove-self-bucket-access": [
            () => isSerializableHeaderValue(input.ConfirmRemoveSelfBucketAccess),
            () => input.ConfirmRemoveSelfBucketAccess.toString(),
        ],
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/policy";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutBucketPolicyRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Policy !== undefined) {
        const node = __XmlNode.of("Policy", input.Policy).withName("Policy");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutBucketReplicationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/replication";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let contents;
    if (input.ReplicationConfiguration !== undefined) {
        contents = se_ReplicationConfiguration(input.ReplicationConfiguration, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
        body += contents.toString();
    }
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutBucketTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let contents;
    if (input.Tagging !== undefined) {
        contents = se_Tagging(input.Tagging, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
        body += contents.toString();
    }
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutBucketVersioningCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
        "x-amz-mfa": input.MFA,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/bucket/{Bucket}/versioning";
    resolvedPath = __resolvedPath(resolvedPath, input, "Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let contents;
    if (input.VersioningConfiguration !== undefined) {
        contents = se_VersioningConfiguration(input.VersioningConfiguration, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
        body += contents.toString();
    }
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutJobTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/jobs/{JobId}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "JobId", () => input.JobId, "{JobId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutJobTaggingRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Tags !== undefined) {
        const nodes = se_S3TagSet(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutMultiRegionAccessPointPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/async-requests/mrap/put-policy";
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutMultiRegionAccessPointPolicyRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.ClientToken === undefined) {
        input.ClientToken = generateIdempotencyToken();
    }
    if (input.ClientToken !== undefined) {
        const node = __XmlNode.of("MultiRegionAccessPointClientToken", input.ClientToken).withName("ClientToken");
        bodyNode.addChildNode(node);
    }
    if (input.Details !== undefined) {
        const node = se_PutMultiRegionAccessPointPolicyInput(input.Details, context).withName("Details");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutPublicAccessBlockCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/configuration/publicAccessBlock";
    let body;
    let contents;
    if (input.PublicAccessBlockConfiguration !== undefined) {
        contents = se_PublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, context);
        body = '<?xml version="1.0" encoding="UTF-8"?>';
        contents.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
        body += contents.toString();
    }
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutStorageLensConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelens/{ConfigId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ConfigId", () => input.ConfigId, "{ConfigId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutStorageLensConfigurationRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.StorageLensConfiguration !== undefined) {
        const node = se_StorageLensConfiguration(input.StorageLensConfiguration, context).withName("StorageLensConfiguration");
        bodyNode.addChildNode(node);
    }
    if (input.Tags !== undefined) {
        const nodes = se_StorageLensTags(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutStorageLensConfigurationTaggingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelens/{ConfigId}/tagging";
    resolvedPath = __resolvedPath(resolvedPath, input, "ConfigId", () => input.ConfigId, "{ConfigId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("PutStorageLensConfigurationTaggingRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Tags !== undefined) {
        const nodes = se_StorageLensTags(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_SubmitMultiRegionAccessPointRoutesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/mrap/instances/{Mrap+}/routes";
    resolvedPath = __resolvedPath(resolvedPath, input, "Mrap", () => input.Mrap, "{Mrap+}", true);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("SubmitMultiRegionAccessPointRoutesRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.RouteUpdates !== undefined) {
        const nodes = se_RouteList(input.RouteUpdates, context);
        const containerNode = new __XmlNode("RouteUpdates");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/tags/{ResourceArn+}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn+}", true);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("TagResourceRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.Tags !== undefined) {
        const nodes = se_TagList(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/tags/{ResourceArn+}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ResourceArn", () => input.ResourceArn, "{ResourceArn+}", true);
    const query = map({
        tagKeys: [
            __expectNonNull(input.TagKeys, `TagKeys`) != null,
            () => (input.TagKeys || []).map((_entry) => _entry),
        ],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_UpdateAccessGrantsLocationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/v20180820/accessgrantsinstance/location/{AccessGrantsLocationId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "AccessGrantsLocationId", () => input.AccessGrantsLocationId, "{AccessGrantsLocationId}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("UpdateAccessGrantsLocationRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.IAMRoleArn !== undefined) {
        const node = __XmlNode.of("IAMRoleArn", input.IAMRoleArn).withName("IAMRoleArn");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_UpdateJobPriorityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/jobs/{JobId}/priority";
    resolvedPath = __resolvedPath(resolvedPath, input, "JobId", () => input.JobId, "{JobId}", false);
    const query = map({
        priority: [__expectNonNull(input.Priority, `Priority`) != null, () => input.Priority.toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_UpdateJobStatusCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/jobs/{JobId}/status";
    resolvedPath = __resolvedPath(resolvedPath, input, "JobId", () => input.JobId, "{JobId}", false);
    const query = map({
        requestedJobStatus: [, __expectNonNull(input.RequestedJobStatus, `RequestedJobStatus`)],
        statusUpdateReason: [, input.StatusUpdateReason],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const se_UpdateStorageLensGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        "x-amz-account-id": input.AccountId,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v20180820/storagelensgroup/{Name}";
    resolvedPath = __resolvedPath(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    const bodyNode = new __XmlNode("UpdateStorageLensGroupRequest");
    bodyNode.addAttribute("xmlns", "http://awss3control.amazonaws.com/doc/2018-08-20/");
    if (input.StorageLensGroup !== undefined) {
        const node = se_StorageLensGroup(input.StorageLensGroup, context).withName("StorageLensGroup");
        bodyNode.addChildNode(node);
    }
    body += bodyNode.toString();
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{AccountId}." + resolvedHostname;
        if (input.AccountId === undefined) {
            throw new Error("Empty value provided for input host prefix: AccountId.");
        }
        resolvedHostname = resolvedHostname.replace("{AccountId}", input.AccountId);
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    return new __HttpRequest({
        protocol,
        hostname: resolvedHostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const de_AssociateAccessGrantsIdentityCenterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AssociateAccessGrantsIdentityCenterCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_AssociateAccessGrantsIdentityCenterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_CreateAccessGrantCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAccessGrantCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessGrantArn"] !== undefined) {
        contents.AccessGrantArn = __expectString(data["AccessGrantArn"]);
    }
    if (data["AccessGrantId"] !== undefined) {
        contents.AccessGrantId = __expectString(data["AccessGrantId"]);
    }
    if (data["AccessGrantsLocationConfiguration"] !== undefined) {
        contents.AccessGrantsLocationConfiguration = de_AccessGrantsLocationConfiguration(data["AccessGrantsLocationConfiguration"], context);
    }
    if (data["AccessGrantsLocationId"] !== undefined) {
        contents.AccessGrantsLocationId = __expectString(data["AccessGrantsLocationId"]);
    }
    if (data["ApplicationArn"] !== undefined) {
        contents.ApplicationArn = __expectString(data["ApplicationArn"]);
    }
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["GrantScope"] !== undefined) {
        contents.GrantScope = __expectString(data["GrantScope"]);
    }
    if (data["Grantee"] !== undefined) {
        contents.Grantee = de_Grantee(data["Grantee"], context);
    }
    if (data["Permission"] !== undefined) {
        contents.Permission = __expectString(data["Permission"]);
    }
    return contents;
};
const de_CreateAccessGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_CreateAccessGrantsInstanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAccessGrantsInstanceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessGrantsInstanceArn"] !== undefined) {
        contents.AccessGrantsInstanceArn = __expectString(data["AccessGrantsInstanceArn"]);
    }
    if (data["AccessGrantsInstanceId"] !== undefined) {
        contents.AccessGrantsInstanceId = __expectString(data["AccessGrantsInstanceId"]);
    }
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["IdentityCenterArn"] !== undefined) {
        contents.IdentityCenterArn = __expectString(data["IdentityCenterArn"]);
    }
    return contents;
};
const de_CreateAccessGrantsInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_CreateAccessGrantsLocationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAccessGrantsLocationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessGrantsLocationArn"] !== undefined) {
        contents.AccessGrantsLocationArn = __expectString(data["AccessGrantsLocationArn"]);
    }
    if (data["AccessGrantsLocationId"] !== undefined) {
        contents.AccessGrantsLocationId = __expectString(data["AccessGrantsLocationId"]);
    }
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["IAMRoleArn"] !== undefined) {
        contents.IAMRoleArn = __expectString(data["IAMRoleArn"]);
    }
    if (data["LocationScope"] !== undefined) {
        contents.LocationScope = __expectString(data["LocationScope"]);
    }
    return contents;
};
const de_CreateAccessGrantsLocationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_CreateAccessPointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAccessPointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessPointArn"] !== undefined) {
        contents.AccessPointArn = __expectString(data["AccessPointArn"]);
    }
    if (data["Alias"] !== undefined) {
        contents.Alias = __expectString(data["Alias"]);
    }
    return contents;
};
const de_CreateAccessPointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_CreateAccessPointForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAccessPointForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Alias"] !== undefined) {
        contents.Alias = de_ObjectLambdaAccessPointAlias(data["Alias"], context);
    }
    if (data["ObjectLambdaAccessPointArn"] !== undefined) {
        contents.ObjectLambdaAccessPointArn = __expectString(data["ObjectLambdaAccessPointArn"]);
    }
    return contents;
};
const de_CreateAccessPointForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_CreateBucketCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateBucketCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        Location: [, output.headers["location"]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["BucketArn"] !== undefined) {
        contents.BucketArn = __expectString(data["BucketArn"]);
    }
    return contents;
};
const de_CreateBucketCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BucketAlreadyExists":
        case "com.amazonaws.s3control#BucketAlreadyExists":
            throw await de_BucketAlreadyExistsRes(parsedOutput, context);
        case "BucketAlreadyOwnedByYou":
        case "com.amazonaws.s3control#BucketAlreadyOwnedByYou":
            throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["JobId"] !== undefined) {
        contents.JobId = __expectString(data["JobId"]);
    }
    return contents;
};
const de_CreateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.s3control#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "IdempotencyException":
        case "com.amazonaws.s3control#IdempotencyException":
            throw await de_IdempotencyExceptionRes(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.s3control#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.s3control#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateMultiRegionAccessPointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateMultiRegionAccessPointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["RequestTokenARN"] !== undefined) {
        contents.RequestTokenARN = __expectString(data["RequestTokenARN"]);
    }
    return contents;
};
const de_CreateMultiRegionAccessPointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_CreateStorageLensGroupCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CreateStorageLensGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CreateStorageLensGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteAccessGrantCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccessGrantCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteAccessGrantsInstanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccessGrantsInstanceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessGrantsInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteAccessGrantsInstanceResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccessGrantsInstanceResourcePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessGrantsInstanceResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteAccessGrantsLocationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccessGrantsLocationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessGrantsLocationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteAccessPointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccessPointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessPointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteAccessPointForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccessPointForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessPointForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteAccessPointPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccessPointPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessPointPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteAccessPointPolicyForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccessPointPolicyForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccessPointPolicyForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteBucketCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteBucketCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteBucketCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteBucketLifecycleConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteBucketLifecycleConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteBucketLifecycleConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteBucketPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteBucketReplicationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteJobTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteJobTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteJobTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.s3control#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.s3control#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.s3control#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteMultiRegionAccessPointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteMultiRegionAccessPointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["RequestTokenARN"] !== undefined) {
        contents.RequestTokenARN = __expectString(data["RequestTokenARN"]);
    }
    return contents;
};
const de_DeleteMultiRegionAccessPointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeletePublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePublicAccessBlockCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeletePublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteStorageLensConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteStorageLensConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteStorageLensConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteStorageLensConfigurationTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteStorageLensConfigurationTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteStorageLensConfigurationTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DeleteStorageLensGroupCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteStorageLensGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteStorageLensGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DescribeJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Job"] !== undefined) {
        contents.Job = de_JobDescriptor(data["Job"], context);
    }
    return contents;
};
const de_DescribeJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.s3control#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.s3control#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.s3control#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.s3control#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeMultiRegionAccessPointOperationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeMultiRegionAccessPointOperationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AsyncOperation"] !== undefined) {
        contents.AsyncOperation = de_AsyncOperation(data["AsyncOperation"], context);
    }
    return contents;
};
const de_DescribeMultiRegionAccessPointOperationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DissociateAccessGrantsIdentityCenterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DissociateAccessGrantsIdentityCenterCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DissociateAccessGrantsIdentityCenterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessGrantCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessGrantCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessGrantArn"] !== undefined) {
        contents.AccessGrantArn = __expectString(data["AccessGrantArn"]);
    }
    if (data["AccessGrantId"] !== undefined) {
        contents.AccessGrantId = __expectString(data["AccessGrantId"]);
    }
    if (data["AccessGrantsLocationConfiguration"] !== undefined) {
        contents.AccessGrantsLocationConfiguration = de_AccessGrantsLocationConfiguration(data["AccessGrantsLocationConfiguration"], context);
    }
    if (data["AccessGrantsLocationId"] !== undefined) {
        contents.AccessGrantsLocationId = __expectString(data["AccessGrantsLocationId"]);
    }
    if (data["ApplicationArn"] !== undefined) {
        contents.ApplicationArn = __expectString(data["ApplicationArn"]);
    }
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["GrantScope"] !== undefined) {
        contents.GrantScope = __expectString(data["GrantScope"]);
    }
    if (data["Grantee"] !== undefined) {
        contents.Grantee = de_Grantee(data["Grantee"], context);
    }
    if (data["Permission"] !== undefined) {
        contents.Permission = __expectString(data["Permission"]);
    }
    return contents;
};
const de_GetAccessGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessGrantsInstanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessGrantsInstanceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessGrantsInstanceArn"] !== undefined) {
        contents.AccessGrantsInstanceArn = __expectString(data["AccessGrantsInstanceArn"]);
    }
    if (data["AccessGrantsInstanceId"] !== undefined) {
        contents.AccessGrantsInstanceId = __expectString(data["AccessGrantsInstanceId"]);
    }
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["IdentityCenterArn"] !== undefined) {
        contents.IdentityCenterArn = __expectString(data["IdentityCenterArn"]);
    }
    return contents;
};
const de_GetAccessGrantsInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessGrantsInstanceForPrefixCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessGrantsInstanceForPrefixCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessGrantsInstanceArn"] !== undefined) {
        contents.AccessGrantsInstanceArn = __expectString(data["AccessGrantsInstanceArn"]);
    }
    if (data["AccessGrantsInstanceId"] !== undefined) {
        contents.AccessGrantsInstanceId = __expectString(data["AccessGrantsInstanceId"]);
    }
    return contents;
};
const de_GetAccessGrantsInstanceForPrefixCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessGrantsInstanceResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessGrantsInstanceResourcePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["Organization"] !== undefined) {
        contents.Organization = __expectString(data["Organization"]);
    }
    if (data["Policy"] !== undefined) {
        contents.Policy = __expectString(data["Policy"]);
    }
    return contents;
};
const de_GetAccessGrantsInstanceResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessGrantsLocationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessGrantsLocationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessGrantsLocationArn"] !== undefined) {
        contents.AccessGrantsLocationArn = __expectString(data["AccessGrantsLocationArn"]);
    }
    if (data["AccessGrantsLocationId"] !== undefined) {
        contents.AccessGrantsLocationId = __expectString(data["AccessGrantsLocationId"]);
    }
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["IAMRoleArn"] !== undefined) {
        contents.IAMRoleArn = __expectString(data["IAMRoleArn"]);
    }
    if (data["LocationScope"] !== undefined) {
        contents.LocationScope = __expectString(data["LocationScope"]);
    }
    return contents;
};
const de_GetAccessGrantsLocationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessPointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessPointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessPointArn"] !== undefined) {
        contents.AccessPointArn = __expectString(data["AccessPointArn"]);
    }
    if (data["Alias"] !== undefined) {
        contents.Alias = __expectString(data["Alias"]);
    }
    if (data["Bucket"] !== undefined) {
        contents.Bucket = __expectString(data["Bucket"]);
    }
    if (data["BucketAccountId"] !== undefined) {
        contents.BucketAccountId = __expectString(data["BucketAccountId"]);
    }
    if (data["CreationDate"] !== undefined) {
        contents.CreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreationDate"]));
    }
    if (data.Endpoints === "") {
        contents.Endpoints = {};
    }
    else if (data["Endpoints"] !== undefined && data["Endpoints"]["entry"] !== undefined) {
        contents.Endpoints = de_Endpoints(__getArrayIfSingleItem(data["Endpoints"]["entry"]), context);
    }
    if (data["Name"] !== undefined) {
        contents.Name = __expectString(data["Name"]);
    }
    if (data["NetworkOrigin"] !== undefined) {
        contents.NetworkOrigin = __expectString(data["NetworkOrigin"]);
    }
    if (data["PublicAccessBlockConfiguration"] !== undefined) {
        contents.PublicAccessBlockConfiguration = de_PublicAccessBlockConfiguration(data["PublicAccessBlockConfiguration"], context);
    }
    if (data["VpcConfiguration"] !== undefined) {
        contents.VpcConfiguration = de_VpcConfiguration(data["VpcConfiguration"], context);
    }
    return contents;
};
const de_GetAccessPointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessPointConfigurationForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessPointConfigurationForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Configuration"] !== undefined) {
        contents.Configuration = de_ObjectLambdaConfiguration(data["Configuration"], context);
    }
    return contents;
};
const de_GetAccessPointConfigurationForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessPointForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessPointForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Alias"] !== undefined) {
        contents.Alias = de_ObjectLambdaAccessPointAlias(data["Alias"], context);
    }
    if (data["CreationDate"] !== undefined) {
        contents.CreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreationDate"]));
    }
    if (data["Name"] !== undefined) {
        contents.Name = __expectString(data["Name"]);
    }
    if (data["PublicAccessBlockConfiguration"] !== undefined) {
        contents.PublicAccessBlockConfiguration = de_PublicAccessBlockConfiguration(data["PublicAccessBlockConfiguration"], context);
    }
    return contents;
};
const de_GetAccessPointForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessPointPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessPointPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Policy"] !== undefined) {
        contents.Policy = __expectString(data["Policy"]);
    }
    return contents;
};
const de_GetAccessPointPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessPointPolicyForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessPointPolicyForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Policy"] !== undefined) {
        contents.Policy = __expectString(data["Policy"]);
    }
    return contents;
};
const de_GetAccessPointPolicyForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessPointPolicyStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessPointPolicyStatusCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["PolicyStatus"] !== undefined) {
        contents.PolicyStatus = de_PolicyStatus(data["PolicyStatus"], context);
    }
    return contents;
};
const de_GetAccessPointPolicyStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccessPointPolicyStatusForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetAccessPointPolicyStatusForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["PolicyStatus"] !== undefined) {
        contents.PolicyStatus = de_PolicyStatus(data["PolicyStatus"], context);
    }
    return contents;
};
const de_GetAccessPointPolicyStatusForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetBucketCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Bucket"] !== undefined) {
        contents.Bucket = __expectString(data["Bucket"]);
    }
    if (data["CreationDate"] !== undefined) {
        contents.CreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreationDate"]));
    }
    if (data["PublicAccessBlockEnabled"] !== undefined) {
        contents.PublicAccessBlockEnabled = __parseBoolean(data["PublicAccessBlockEnabled"]);
    }
    return contents;
};
const de_GetBucketCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetBucketLifecycleConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketLifecycleConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.Rules === "") {
        contents.Rules = [];
    }
    else if (data["Rules"] !== undefined && data["Rules"]["Rule"] !== undefined) {
        contents.Rules = de_LifecycleRules(__getArrayIfSingleItem(data["Rules"]["Rule"]), context);
    }
    return contents;
};
const de_GetBucketLifecycleConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Policy"] !== undefined) {
        contents.Policy = __expectString(data["Policy"]);
    }
    return contents;
};
const de_GetBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketReplicationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["ReplicationConfiguration"] !== undefined) {
        contents.ReplicationConfiguration = de_ReplicationConfiguration(data["ReplicationConfiguration"], context);
    }
    return contents;
};
const de_GetBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.TagSet === "") {
        contents.TagSet = [];
    }
    else if (data["TagSet"] !== undefined && data["TagSet"]["member"] !== undefined) {
        contents.TagSet = de_S3TagSet(__getArrayIfSingleItem(data["TagSet"]["member"]), context);
    }
    return contents;
};
const de_GetBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetBucketVersioningCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketVersioningCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["MfaDelete"] !== undefined) {
        contents.MFADelete = __expectString(data["MfaDelete"]);
    }
    if (data["Status"] !== undefined) {
        contents.Status = __expectString(data["Status"]);
    }
    return contents;
};
const de_GetBucketVersioningCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetDataAccessCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDataAccessCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(data["Credentials"], context);
    }
    if (data["MatchedGrantTarget"] !== undefined) {
        contents.MatchedGrantTarget = __expectString(data["MatchedGrantTarget"]);
    }
    return contents;
};
const de_GetDataAccessCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetJobTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetJobTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.Tags === "") {
        contents.Tags = [];
    }
    else if (data["Tags"] !== undefined && data["Tags"]["member"] !== undefined) {
        contents.Tags = de_S3TagSet(__getArrayIfSingleItem(data["Tags"]["member"]), context);
    }
    return contents;
};
const de_GetJobTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.s3control#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.s3control#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.s3control#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetMultiRegionAccessPointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMultiRegionAccessPointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessPoint"] !== undefined) {
        contents.AccessPoint = de_MultiRegionAccessPointReport(data["AccessPoint"], context);
    }
    return contents;
};
const de_GetMultiRegionAccessPointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetMultiRegionAccessPointPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMultiRegionAccessPointPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Policy"] !== undefined) {
        contents.Policy = de_MultiRegionAccessPointPolicyDocument(data["Policy"], context);
    }
    return contents;
};
const de_GetMultiRegionAccessPointPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetMultiRegionAccessPointPolicyStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMultiRegionAccessPointPolicyStatusCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Established"] !== undefined) {
        contents.Established = de_PolicyStatus(data["Established"], context);
    }
    return contents;
};
const de_GetMultiRegionAccessPointPolicyStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetMultiRegionAccessPointRoutesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMultiRegionAccessPointRoutesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["Mrap"] !== undefined) {
        contents.Mrap = __expectString(data["Mrap"]);
    }
    if (data.Routes === "") {
        contents.Routes = [];
    }
    else if (data["Routes"] !== undefined && data["Routes"]["Route"] !== undefined) {
        contents.Routes = de_RouteList(__getArrayIfSingleItem(data["Routes"]["Route"]), context);
    }
    return contents;
};
const de_GetMultiRegionAccessPointRoutesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetPublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPublicAccessBlockCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectObject(await parseBody(output.body, context));
    contents.PublicAccessBlockConfiguration = de_PublicAccessBlockConfiguration(data, context);
    return contents;
};
const de_GetPublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchPublicAccessBlockConfiguration":
        case "com.amazonaws.s3control#NoSuchPublicAccessBlockConfiguration":
            throw await de_NoSuchPublicAccessBlockConfigurationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetStorageLensConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStorageLensConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectObject(await parseBody(output.body, context));
    contents.StorageLensConfiguration = de_StorageLensConfiguration(data, context);
    return contents;
};
const de_GetStorageLensConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetStorageLensConfigurationTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStorageLensConfigurationTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.Tags === "") {
        contents.Tags = [];
    }
    else if (data["Tags"] !== undefined && data["Tags"]["Tag"] !== undefined) {
        contents.Tags = de_StorageLensTags(__getArrayIfSingleItem(data["Tags"]["Tag"]), context);
    }
    return contents;
};
const de_GetStorageLensConfigurationTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetStorageLensGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStorageLensGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectObject(await parseBody(output.body, context));
    contents.StorageLensGroup = de_StorageLensGroup(data, context);
    return contents;
};
const de_GetStorageLensGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListAccessGrantsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccessGrantsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.AccessGrantsList === "") {
        contents.AccessGrantsList = [];
    }
    else if (data["AccessGrantsList"] !== undefined && data["AccessGrantsList"]["AccessGrant"] !== undefined) {
        contents.AccessGrantsList = de_AccessGrantsList(__getArrayIfSingleItem(data["AccessGrantsList"]["AccessGrant"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListAccessGrantsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListAccessGrantsInstancesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccessGrantsInstancesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.AccessGrantsInstancesList === "") {
        contents.AccessGrantsInstancesList = [];
    }
    else if (data["AccessGrantsInstancesList"] !== undefined &&
        data["AccessGrantsInstancesList"]["AccessGrantsInstance"] !== undefined) {
        contents.AccessGrantsInstancesList = de_AccessGrantsInstancesList(__getArrayIfSingleItem(data["AccessGrantsInstancesList"]["AccessGrantsInstance"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListAccessGrantsInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListAccessGrantsLocationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccessGrantsLocationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.AccessGrantsLocationsList === "") {
        contents.AccessGrantsLocationsList = [];
    }
    else if (data["AccessGrantsLocationsList"] !== undefined &&
        data["AccessGrantsLocationsList"]["AccessGrantsLocation"] !== undefined) {
        contents.AccessGrantsLocationsList = de_AccessGrantsLocationsList(__getArrayIfSingleItem(data["AccessGrantsLocationsList"]["AccessGrantsLocation"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListAccessGrantsLocationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListAccessPointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccessPointsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.AccessPointList === "") {
        contents.AccessPointList = [];
    }
    else if (data["AccessPointList"] !== undefined && data["AccessPointList"]["AccessPoint"] !== undefined) {
        contents.AccessPointList = de_AccessPointList(__getArrayIfSingleItem(data["AccessPointList"]["AccessPoint"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListAccessPointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListAccessPointsForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccessPointsForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    if (data.ObjectLambdaAccessPointList === "") {
        contents.ObjectLambdaAccessPointList = [];
    }
    else if (data["ObjectLambdaAccessPointList"] !== undefined &&
        data["ObjectLambdaAccessPointList"]["ObjectLambdaAccessPoint"] !== undefined) {
        contents.ObjectLambdaAccessPointList = de_ObjectLambdaAccessPointList(__getArrayIfSingleItem(data["ObjectLambdaAccessPointList"]["ObjectLambdaAccessPoint"]), context);
    }
    return contents;
};
const de_ListAccessPointsForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.Jobs === "") {
        contents.Jobs = [];
    }
    else if (data["Jobs"] !== undefined && data["Jobs"]["member"] !== undefined) {
        contents.Jobs = de_JobListDescriptorList(__getArrayIfSingleItem(data["Jobs"]["member"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.s3control#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.s3control#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.s3control#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListMultiRegionAccessPointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListMultiRegionAccessPointsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.AccessPoints === "") {
        contents.AccessPoints = [];
    }
    else if (data["AccessPoints"] !== undefined && data["AccessPoints"]["AccessPoint"] !== undefined) {
        contents.AccessPoints = de_MultiRegionAccessPointReportList(__getArrayIfSingleItem(data["AccessPoints"]["AccessPoint"]), context);
    }
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    return contents;
};
const de_ListMultiRegionAccessPointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListRegionalBucketsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListRegionalBucketsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    if (data.RegionalBucketList === "") {
        contents.RegionalBucketList = [];
    }
    else if (data["RegionalBucketList"] !== undefined && data["RegionalBucketList"]["RegionalBucket"] !== undefined) {
        contents.RegionalBucketList = de_RegionalBucketList(__getArrayIfSingleItem(data["RegionalBucketList"]["RegionalBucket"]), context);
    }
    return contents;
};
const de_ListRegionalBucketsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListStorageLensConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListStorageLensConfigurationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    if (data.StorageLensConfigurationList === "") {
        contents.StorageLensConfigurationList = [];
    }
    else if (data["StorageLensConfigurationList"] !== undefined) {
        contents.StorageLensConfigurationList = de_StorageLensConfigurationList(__getArrayIfSingleItem(data["StorageLensConfigurationList"]), context);
    }
    return contents;
};
const de_ListStorageLensConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListStorageLensGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListStorageLensGroupsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["NextToken"] !== undefined) {
        contents.NextToken = __expectString(data["NextToken"]);
    }
    if (data.StorageLensGroupList === "") {
        contents.StorageLensGroupList = [];
    }
    else if (data["StorageLensGroupList"] !== undefined) {
        contents.StorageLensGroupList = de_StorageLensGroupList(__getArrayIfSingleItem(data["StorageLensGroupList"]), context);
    }
    return contents;
};
const de_ListStorageLensGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.Tags === "") {
        contents.Tags = [];
    }
    else if (data["Tags"] !== undefined && data["Tags"]["Tag"] !== undefined) {
        contents.Tags = de_TagList(__getArrayIfSingleItem(data["Tags"]["Tag"]), context);
    }
    return contents;
};
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutAccessGrantsInstanceResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutAccessGrantsInstanceResourcePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["Organization"] !== undefined) {
        contents.Organization = __expectString(data["Organization"]);
    }
    if (data["Policy"] !== undefined) {
        contents.Policy = __expectString(data["Policy"]);
    }
    return contents;
};
const de_PutAccessGrantsInstanceResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutAccessPointConfigurationForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutAccessPointConfigurationForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutAccessPointConfigurationForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutAccessPointPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutAccessPointPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutAccessPointPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutAccessPointPolicyForObjectLambdaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutAccessPointPolicyForObjectLambdaCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutAccessPointPolicyForObjectLambdaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutBucketLifecycleConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketLifecycleConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutBucketLifecycleConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketReplicationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutBucketVersioningCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketVersioningCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutBucketVersioningCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutJobTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutJobTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutJobTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.s3control#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.s3control#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.s3control#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.s3control#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutMultiRegionAccessPointPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutMultiRegionAccessPointPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["RequestTokenARN"] !== undefined) {
        contents.RequestTokenARN = __expectString(data["RequestTokenARN"]);
    }
    return contents;
};
const de_PutMultiRegionAccessPointPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutPublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutPublicAccessBlockCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutPublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutStorageLensConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutStorageLensConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutStorageLensConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutStorageLensConfigurationTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutStorageLensConfigurationTaggingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutStorageLensConfigurationTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_SubmitMultiRegionAccessPointRoutesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SubmitMultiRegionAccessPointRoutesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_SubmitMultiRegionAccessPointRoutesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_UpdateAccessGrantsLocationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAccessGrantsLocationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["AccessGrantsLocationArn"] !== undefined) {
        contents.AccessGrantsLocationArn = __expectString(data["AccessGrantsLocationArn"]);
    }
    if (data["AccessGrantsLocationId"] !== undefined) {
        contents.AccessGrantsLocationId = __expectString(data["AccessGrantsLocationId"]);
    }
    if (data["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(data["CreatedAt"]));
    }
    if (data["IAMRoleArn"] !== undefined) {
        contents.IAMRoleArn = __expectString(data["IAMRoleArn"]);
    }
    if (data["LocationScope"] !== undefined) {
        contents.LocationScope = __expectString(data["LocationScope"]);
    }
    return contents;
};
const de_UpdateAccessGrantsLocationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_UpdateJobPriorityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateJobPriorityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["JobId"] !== undefined) {
        contents.JobId = __expectString(data["JobId"]);
    }
    if (data["Priority"] !== undefined) {
        contents.Priority = __strictParseInt32(data["Priority"]);
    }
    return contents;
};
const de_UpdateJobPriorityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.s3control#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.s3control#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.s3control#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.s3control#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateJobStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateJobStatusCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data["JobId"] !== undefined) {
        contents.JobId = __expectString(data["JobId"]);
    }
    if (data["Status"] !== undefined) {
        contents.Status = __expectString(data["Status"]);
    }
    if (data["StatusUpdateReason"] !== undefined) {
        contents.StatusUpdateReason = __expectString(data["StatusUpdateReason"]);
    }
    return contents;
};
const de_UpdateJobStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.s3control#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.s3control#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "JobStatusException":
        case "com.amazonaws.s3control#JobStatusException":
            throw await de_JobStatusExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.s3control#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.s3control#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateStorageLensGroupCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UpdateStorageLensGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateStorageLensGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const throwDefaultError = withBaseException(__BaseException);
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    const exception = new BucketAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    const exception = new BucketAlreadyOwnedByYou({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_IdempotencyExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new IdempotencyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InternalServiceExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new InternalServiceException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidNextTokenExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new InvalidNextTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_JobStatusExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new JobStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NoSuchPublicAccessBlockConfigurationRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new NoSuchPublicAccessBlockConfiguration({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body.Error;
    if (data["Message"] !== undefined) {
        contents.Message = __expectString(data["Message"]);
    }
    const exception = new TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body.Error);
};
const se_AbortIncompleteMultipartUpload = (input, context) => {
    const bodyNode = new __XmlNode("AbortIncompleteMultipartUpload");
    if (input.DaysAfterInitiation != null) {
        const node = __XmlNode.of("DaysAfterInitiation", String(input.DaysAfterInitiation)).withName("DaysAfterInitiation");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_AccessControlTranslation = (input, context) => {
    const bodyNode = new __XmlNode("AccessControlTranslation");
    if (input.Owner != null) {
        const node = __XmlNode.of("OwnerOverride", input.Owner).withName("Owner");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_AccessGrantsLocationConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("AccessGrantsLocationConfiguration");
    if (input.S3SubPrefix != null) {
        const node = __XmlNode.of("S3Prefix", input.S3SubPrefix).withName("S3SubPrefix");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_AccountLevel = (input, context) => {
    const bodyNode = new __XmlNode("AccountLevel");
    if (input.ActivityMetrics != null) {
        const node = se_ActivityMetrics(input.ActivityMetrics, context).withName("ActivityMetrics");
        bodyNode.addChildNode(node);
    }
    if (input.BucketLevel != null) {
        const node = se_BucketLevel(input.BucketLevel, context).withName("BucketLevel");
        bodyNode.addChildNode(node);
    }
    if (input.AdvancedCostOptimizationMetrics != null) {
        const node = se_AdvancedCostOptimizationMetrics(input.AdvancedCostOptimizationMetrics, context).withName("AdvancedCostOptimizationMetrics");
        bodyNode.addChildNode(node);
    }
    if (input.AdvancedDataProtectionMetrics != null) {
        const node = se_AdvancedDataProtectionMetrics(input.AdvancedDataProtectionMetrics, context).withName("AdvancedDataProtectionMetrics");
        bodyNode.addChildNode(node);
    }
    if (input.DetailedStatusCodesMetrics != null) {
        const node = se_DetailedStatusCodesMetrics(input.DetailedStatusCodesMetrics, context).withName("DetailedStatusCodesMetrics");
        bodyNode.addChildNode(node);
    }
    if (input.StorageLensGroupLevel != null) {
        const node = se_StorageLensGroupLevel(input.StorageLensGroupLevel, context).withName("StorageLensGroupLevel");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ActivityMetrics = (input, context) => {
    const bodyNode = new __XmlNode("ActivityMetrics");
    if (input.IsEnabled != null) {
        const node = __XmlNode.of("IsEnabled", String(input.IsEnabled)).withName("IsEnabled");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_AdvancedCostOptimizationMetrics = (input, context) => {
    const bodyNode = new __XmlNode("AdvancedCostOptimizationMetrics");
    if (input.IsEnabled != null) {
        const node = __XmlNode.of("IsEnabled", String(input.IsEnabled)).withName("IsEnabled");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_AdvancedDataProtectionMetrics = (input, context) => {
    const bodyNode = new __XmlNode("AdvancedDataProtectionMetrics");
    if (input.IsEnabled != null) {
        const node = __XmlNode.of("IsEnabled", String(input.IsEnabled)).withName("IsEnabled");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_AwsLambdaTransformation = (input, context) => {
    const bodyNode = new __XmlNode("AwsLambdaTransformation");
    if (input.FunctionArn != null) {
        const node = __XmlNode.of("FunctionArnString", input.FunctionArn).withName("FunctionArn");
        bodyNode.addChildNode(node);
    }
    if (input.FunctionPayload != null) {
        const node = __XmlNode.of("AwsLambdaTransformationPayload", input.FunctionPayload).withName("FunctionPayload");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_BucketLevel = (input, context) => {
    const bodyNode = new __XmlNode("BucketLevel");
    if (input.ActivityMetrics != null) {
        const node = se_ActivityMetrics(input.ActivityMetrics, context).withName("ActivityMetrics");
        bodyNode.addChildNode(node);
    }
    if (input.PrefixLevel != null) {
        const node = se_PrefixLevel(input.PrefixLevel, context).withName("PrefixLevel");
        bodyNode.addChildNode(node);
    }
    if (input.AdvancedCostOptimizationMetrics != null) {
        const node = se_AdvancedCostOptimizationMetrics(input.AdvancedCostOptimizationMetrics, context).withName("AdvancedCostOptimizationMetrics");
        bodyNode.addChildNode(node);
    }
    if (input.AdvancedDataProtectionMetrics != null) {
        const node = se_AdvancedDataProtectionMetrics(input.AdvancedDataProtectionMetrics, context).withName("AdvancedDataProtectionMetrics");
        bodyNode.addChildNode(node);
    }
    if (input.DetailedStatusCodesMetrics != null) {
        const node = se_DetailedStatusCodesMetrics(input.DetailedStatusCodesMetrics, context).withName("DetailedStatusCodesMetrics");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Buckets = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("S3BucketArnString", entry);
        return node.withName("Arn");
    });
};
const se_CloudWatchMetrics = (input, context) => {
    const bodyNode = new __XmlNode("CloudWatchMetrics");
    if (input.IsEnabled != null) {
        const node = __XmlNode.of("IsEnabled", String(input.IsEnabled)).withName("IsEnabled");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_CreateBucketConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("CreateBucketConfiguration");
    if (input.LocationConstraint != null) {
        const node = __XmlNode.of("BucketLocationConstraint", input.LocationConstraint).withName("LocationConstraint");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_CreateMultiRegionAccessPointInput = (input, context) => {
    const bodyNode = new __XmlNode("CreateMultiRegionAccessPointInput");
    if (input.Name != null) {
        const node = __XmlNode.of("MultiRegionAccessPointName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.PublicAccessBlock != null) {
        const node = se_PublicAccessBlockConfiguration(input.PublicAccessBlock, context).withName("PublicAccessBlock");
        bodyNode.addChildNode(node);
    }
    if (input.Regions != null) {
        const nodes = se_RegionCreationList(input.Regions, context);
        const containerNode = new __XmlNode("Regions");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_DeleteMarkerReplication = (input, context) => {
    const bodyNode = new __XmlNode("DeleteMarkerReplication");
    if (input.Status != null) {
        const node = __XmlNode.of("DeleteMarkerReplicationStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_DeleteMultiRegionAccessPointInput = (input, context) => {
    const bodyNode = new __XmlNode("DeleteMultiRegionAccessPointInput");
    if (input.Name != null) {
        const node = __XmlNode.of("MultiRegionAccessPointName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Destination = (input, context) => {
    const bodyNode = new __XmlNode("Destination");
    if (input.Account != null) {
        const node = __XmlNode.of("AccountId", input.Account).withName("Account");
        bodyNode.addChildNode(node);
    }
    if (input.Bucket != null) {
        const node = __XmlNode.of("BucketIdentifierString", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    if (input.ReplicationTime != null) {
        const node = se_ReplicationTime(input.ReplicationTime, context).withName("ReplicationTime");
        bodyNode.addChildNode(node);
    }
    if (input.AccessControlTranslation != null) {
        const node = se_AccessControlTranslation(input.AccessControlTranslation, context).withName("AccessControlTranslation");
        bodyNode.addChildNode(node);
    }
    if (input.EncryptionConfiguration != null) {
        const node = se_EncryptionConfiguration(input.EncryptionConfiguration, context).withName("EncryptionConfiguration");
        bodyNode.addChildNode(node);
    }
    if (input.Metrics != null) {
        const node = se_Metrics(input.Metrics, context).withName("Metrics");
        bodyNode.addChildNode(node);
    }
    if (input.StorageClass != null) {
        const node = __XmlNode.of("ReplicationStorageClass", input.StorageClass).withName("StorageClass");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_DetailedStatusCodesMetrics = (input, context) => {
    const bodyNode = new __XmlNode("DetailedStatusCodesMetrics");
    if (input.IsEnabled != null) {
        const node = __XmlNode.of("IsEnabled", String(input.IsEnabled)).withName("IsEnabled");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_EncryptionConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("EncryptionConfiguration");
    if (input.ReplicaKmsKeyID != null) {
        const node = __XmlNode.of("ReplicaKmsKeyID", input.ReplicaKmsKeyID).withName("ReplicaKmsKeyID");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se__Exclude = (input, context) => {
    const bodyNode = new __XmlNode("Exclude");
    if (input.Buckets != null) {
        const nodes = se_Buckets(input.Buckets, context);
        const containerNode = new __XmlNode("Buckets");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Regions != null) {
        const nodes = se_Regions(input.Regions, context);
        const containerNode = new __XmlNode("Regions");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_ExistingObjectReplication = (input, context) => {
    const bodyNode = new __XmlNode("ExistingObjectReplication");
    if (input.Status != null) {
        const node = __XmlNode.of("ExistingObjectReplicationStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_GeneratedManifestEncryption = (input, context) => {
    const bodyNode = new __XmlNode("GeneratedManifestEncryption");
    if (input.SSES3 != null) {
        const node = se_SSES3Encryption(input.SSES3, context).withName("SSE-S3");
        bodyNode.addChildNode(node);
    }
    if (input.SSEKMS != null) {
        const node = se_SSEKMSEncryption(input.SSEKMS, context).withName("SSE-KMS");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Grantee = (input, context) => {
    const bodyNode = new __XmlNode("Grantee");
    if (input.GranteeType != null) {
        const node = __XmlNode.of("GranteeType", input.GranteeType).withName("GranteeType");
        bodyNode.addChildNode(node);
    }
    if (input.GranteeIdentifier != null) {
        const node = __XmlNode.of("GranteeIdentifier", input.GranteeIdentifier).withName("GranteeIdentifier");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Include = (input, context) => {
    const bodyNode = new __XmlNode("Include");
    if (input.Buckets != null) {
        const nodes = se_Buckets(input.Buckets, context);
        const containerNode = new __XmlNode("Buckets");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Regions != null) {
        const nodes = se_Regions(input.Regions, context);
        const containerNode = new __XmlNode("Regions");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_JobManifest = (input, context) => {
    const bodyNode = new __XmlNode("JobManifest");
    if (input.Spec != null) {
        const node = se_JobManifestSpec(input.Spec, context).withName("Spec");
        bodyNode.addChildNode(node);
    }
    if (input.Location != null) {
        const node = se_JobManifestLocation(input.Location, context).withName("Location");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_JobManifestFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("JobManifestFieldName", entry);
        return node.withName("member");
    });
};
const se_JobManifestGenerator = (input, context) => {
    const bodyNode = new __XmlNode("JobManifestGenerator");
    JobManifestGenerator.visit(input, {
        S3JobManifestGenerator: (value) => {
            const node = se_S3JobManifestGenerator(value, context).withName("S3JobManifestGenerator");
            bodyNode.addChildNode(node);
        },
        _: (name, value) => {
            if (!(value instanceof __XmlNode || value instanceof __XmlText)) {
                throw new Error("Unable to serialize unknown union members in XML.");
            }
            bodyNode.addChildNode(new __XmlNode(name).addChildNode(value));
        },
    });
    return bodyNode;
};
const se_JobManifestGeneratorFilter = (input, context) => {
    const bodyNode = new __XmlNode("JobManifestGeneratorFilter");
    if (input.EligibleForReplication != null) {
        const node = __XmlNode.of("Boolean", String(input.EligibleForReplication)).withName("EligibleForReplication");
        bodyNode.addChildNode(node);
    }
    if (input.CreatedAfter != null) {
        const node = __XmlNode
            .of("ObjectCreationTime", input.CreatedAfter.toISOString().split(".")[0] + "Z")
            .withName("CreatedAfter");
        bodyNode.addChildNode(node);
    }
    if (input.CreatedBefore != null) {
        const node = __XmlNode
            .of("ObjectCreationTime", input.CreatedBefore.toISOString().split(".")[0] + "Z")
            .withName("CreatedBefore");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectReplicationStatuses != null) {
        const nodes = se_ReplicationStatusFilterList(input.ObjectReplicationStatuses, context);
        const containerNode = new __XmlNode("ObjectReplicationStatuses");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.KeyNameConstraint != null) {
        const node = se_KeyNameConstraint(input.KeyNameConstraint, context).withName("KeyNameConstraint");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectSizeGreaterThanBytes != null) {
        const node = __XmlNode
            .of("ObjectSizeGreaterThanBytes", String(input.ObjectSizeGreaterThanBytes))
            .withName("ObjectSizeGreaterThanBytes");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectSizeLessThanBytes != null) {
        const node = __XmlNode
            .of("ObjectSizeLessThanBytes", String(input.ObjectSizeLessThanBytes))
            .withName("ObjectSizeLessThanBytes");
        bodyNode.addChildNode(node);
    }
    if (input.MatchAnyStorageClass != null) {
        const nodes = se_StorageClassList(input.MatchAnyStorageClass, context);
        const containerNode = new __XmlNode("MatchAnyStorageClass");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_JobManifestLocation = (input, context) => {
    const bodyNode = new __XmlNode("JobManifestLocation");
    if (input.ObjectArn != null) {
        const node = __XmlNode.of("S3KeyArnString", input.ObjectArn).withName("ObjectArn");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectVersionId != null) {
        const node = __XmlNode.of("S3ObjectVersionId", input.ObjectVersionId).withName("ObjectVersionId");
        bodyNode.addChildNode(node);
    }
    if (input.ETag != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.ETag).withName("ETag");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_JobManifestSpec = (input, context) => {
    const bodyNode = new __XmlNode("JobManifestSpec");
    if (input.Format != null) {
        const node = __XmlNode.of("JobManifestFormat", input.Format).withName("Format");
        bodyNode.addChildNode(node);
    }
    if (input.Fields != null) {
        const nodes = se_JobManifestFieldList(input.Fields, context);
        const containerNode = new __XmlNode("Fields");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_JobOperation = (input, context) => {
    const bodyNode = new __XmlNode("JobOperation");
    if (input.LambdaInvoke != null) {
        const node = se_LambdaInvokeOperation(input.LambdaInvoke, context).withName("LambdaInvoke");
        bodyNode.addChildNode(node);
    }
    if (input.S3PutObjectCopy != null) {
        const node = se_S3CopyObjectOperation(input.S3PutObjectCopy, context).withName("S3PutObjectCopy");
        bodyNode.addChildNode(node);
    }
    if (input.S3PutObjectAcl != null) {
        const node = se_S3SetObjectAclOperation(input.S3PutObjectAcl, context).withName("S3PutObjectAcl");
        bodyNode.addChildNode(node);
    }
    if (input.S3PutObjectTagging != null) {
        const node = se_S3SetObjectTaggingOperation(input.S3PutObjectTagging, context).withName("S3PutObjectTagging");
        bodyNode.addChildNode(node);
    }
    if (input.S3DeleteObjectTagging != null) {
        const node = se_S3DeleteObjectTaggingOperation(input.S3DeleteObjectTagging, context).withName("S3DeleteObjectTagging");
        bodyNode.addChildNode(node);
    }
    if (input.S3InitiateRestoreObject != null) {
        const node = se_S3InitiateRestoreObjectOperation(input.S3InitiateRestoreObject, context).withName("S3InitiateRestoreObject");
        bodyNode.addChildNode(node);
    }
    if (input.S3PutObjectLegalHold != null) {
        const node = se_S3SetObjectLegalHoldOperation(input.S3PutObjectLegalHold, context).withName("S3PutObjectLegalHold");
        bodyNode.addChildNode(node);
    }
    if (input.S3PutObjectRetention != null) {
        const node = se_S3SetObjectRetentionOperation(input.S3PutObjectRetention, context).withName("S3PutObjectRetention");
        bodyNode.addChildNode(node);
    }
    if (input.S3ReplicateObject != null) {
        const node = se_S3ReplicateObjectOperation(input.S3ReplicateObject, context).withName("S3ReplicateObject");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_JobReport = (input, context) => {
    const bodyNode = new __XmlNode("JobReport");
    if (input.Bucket != null) {
        const node = __XmlNode.of("S3BucketArnString", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    if (input.Format != null) {
        const node = __XmlNode.of("JobReportFormat", input.Format).withName("Format");
        bodyNode.addChildNode(node);
    }
    if (input.Enabled != null) {
        const node = __XmlNode.of("Boolean", String(input.Enabled)).withName("Enabled");
        bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
        const node = __XmlNode.of("ReportPrefixString", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    if (input.ReportScope != null) {
        const node = __XmlNode.of("JobReportScope", input.ReportScope).withName("ReportScope");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_KeyNameConstraint = (input, context) => {
    const bodyNode = new __XmlNode("KeyNameConstraint");
    if (input.MatchAnyPrefix != null) {
        const nodes = se_NonEmptyMaxLength1024StringList(input.MatchAnyPrefix, context);
        const containerNode = new __XmlNode("MatchAnyPrefix");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchAnySuffix != null) {
        const nodes = se_NonEmptyMaxLength1024StringList(input.MatchAnySuffix, context);
        const containerNode = new __XmlNode("MatchAnySuffix");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchAnySubstring != null) {
        const nodes = se_NonEmptyMaxLength1024StringList(input.MatchAnySubstring, context);
        const containerNode = new __XmlNode("MatchAnySubstring");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_LambdaInvokeOperation = (input, context) => {
    const bodyNode = new __XmlNode("LambdaInvokeOperation");
    if (input.FunctionArn != null) {
        const node = __XmlNode.of("FunctionArnString", input.FunctionArn).withName("FunctionArn");
        bodyNode.addChildNode(node);
    }
    if (input.InvocationSchemaVersion != null) {
        const node = __XmlNode
            .of("NonEmptyMaxLength64String", input.InvocationSchemaVersion)
            .withName("InvocationSchemaVersion");
        bodyNode.addChildNode(node);
    }
    if (input.UserArguments != null) {
        const nodes = se_UserArguments(input.UserArguments, context);
        const containerNode = new __XmlNode("UserArguments");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_LifecycleConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("LifecycleConfiguration");
    if (input.Rules != null) {
        const nodes = se_LifecycleRules(input.Rules, context);
        const containerNode = new __XmlNode("Rules");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_LifecycleExpiration = (input, context) => {
    const bodyNode = new __XmlNode("LifecycleExpiration");
    if (input.Date != null) {
        const node = __XmlNode.of("Date", input.Date.toISOString().split(".")[0] + "Z").withName("Date");
        bodyNode.addChildNode(node);
    }
    if (input.Days != null) {
        const node = __XmlNode.of("Days", String(input.Days)).withName("Days");
        bodyNode.addChildNode(node);
    }
    if (input.ExpiredObjectDeleteMarker != null) {
        const node = __XmlNode
            .of("ExpiredObjectDeleteMarker", String(input.ExpiredObjectDeleteMarker))
            .withName("ExpiredObjectDeleteMarker");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_LifecycleRule = (input, context) => {
    const bodyNode = new __XmlNode("LifecycleRule");
    if (input.Expiration != null) {
        const node = se_LifecycleExpiration(input.Expiration, context).withName("Expiration");
        bodyNode.addChildNode(node);
    }
    if (input.ID != null) {
        const node = __XmlNode.of("ID", input.ID).withName("ID");
        bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
        const node = se_LifecycleRuleFilter(input.Filter, context).withName("Filter");
        bodyNode.addChildNode(node);
    }
    if (input.Status != null) {
        const node = __XmlNode.of("ExpirationStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    if (input.Transitions != null) {
        const nodes = se_TransitionList(input.Transitions, context);
        const containerNode = new __XmlNode("Transitions");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.NoncurrentVersionTransitions != null) {
        const nodes = se_NoncurrentVersionTransitionList(input.NoncurrentVersionTransitions, context);
        const containerNode = new __XmlNode("NoncurrentVersionTransitions");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.NoncurrentVersionExpiration != null) {
        const node = se_NoncurrentVersionExpiration(input.NoncurrentVersionExpiration, context).withName("NoncurrentVersionExpiration");
        bodyNode.addChildNode(node);
    }
    if (input.AbortIncompleteMultipartUpload != null) {
        const node = se_AbortIncompleteMultipartUpload(input.AbortIncompleteMultipartUpload, context).withName("AbortIncompleteMultipartUpload");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_LifecycleRuleAndOperator = (input, context) => {
    const bodyNode = new __XmlNode("LifecycleRuleAndOperator");
    if (input.Prefix != null) {
        const node = __XmlNode.of("Prefix", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
        const nodes = se_S3TagSet(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.ObjectSizeGreaterThan != null) {
        const node = __XmlNode
            .of("ObjectSizeGreaterThanBytes", String(input.ObjectSizeGreaterThan))
            .withName("ObjectSizeGreaterThan");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectSizeLessThan != null) {
        const node = __XmlNode
            .of("ObjectSizeLessThanBytes", String(input.ObjectSizeLessThan))
            .withName("ObjectSizeLessThan");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_LifecycleRuleFilter = (input, context) => {
    const bodyNode = new __XmlNode("LifecycleRuleFilter");
    if (input.Prefix != null) {
        const node = __XmlNode.of("Prefix", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    if (input.Tag != null) {
        const node = se_S3Tag(input.Tag, context).withName("Tag");
        bodyNode.addChildNode(node);
    }
    if (input.And != null) {
        const node = se_LifecycleRuleAndOperator(input.And, context).withName("And");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectSizeGreaterThan != null) {
        const node = __XmlNode
            .of("ObjectSizeGreaterThanBytes", String(input.ObjectSizeGreaterThan))
            .withName("ObjectSizeGreaterThan");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectSizeLessThan != null) {
        const node = __XmlNode
            .of("ObjectSizeLessThanBytes", String(input.ObjectSizeLessThan))
            .withName("ObjectSizeLessThan");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_LifecycleRules = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_LifecycleRule(entry, context);
        return node.withName("Rule");
    });
};
const se_MatchAnyPrefix = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("Prefix", entry);
        return node.withName("Prefix");
    });
};
const se_MatchAnySuffix = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("Suffix", entry);
        return node.withName("Suffix");
    });
};
const se_MatchAnyTag = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_S3Tag(entry, context);
        return node.withName("Tag");
    });
};
const se_MatchObjectAge = (input, context) => {
    const bodyNode = new __XmlNode("MatchObjectAge");
    if (input.DaysGreaterThan != null) {
        const node = __XmlNode.of("ObjectAgeValue", String(input.DaysGreaterThan)).withName("DaysGreaterThan");
        bodyNode.addChildNode(node);
    }
    if (input.DaysLessThan != null) {
        const node = __XmlNode.of("ObjectAgeValue", String(input.DaysLessThan)).withName("DaysLessThan");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_MatchObjectSize = (input, context) => {
    const bodyNode = new __XmlNode("MatchObjectSize");
    if (input.BytesGreaterThan != null) {
        const node = __XmlNode.of("ObjectSizeValue", String(input.BytesGreaterThan)).withName("BytesGreaterThan");
        bodyNode.addChildNode(node);
    }
    if (input.BytesLessThan != null) {
        const node = __XmlNode.of("ObjectSizeValue", String(input.BytesLessThan)).withName("BytesLessThan");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Metrics = (input, context) => {
    const bodyNode = new __XmlNode("Metrics");
    if (input.Status != null) {
        const node = __XmlNode.of("MetricsStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    if (input.EventThreshold != null) {
        const node = se_ReplicationTimeValue(input.EventThreshold, context).withName("EventThreshold");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_MultiRegionAccessPointRoute = (input, context) => {
    const bodyNode = new __XmlNode("MultiRegionAccessPointRoute");
    if (input.Bucket != null) {
        const node = __XmlNode.of("BucketName", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    if (input.Region != null) {
        const node = __XmlNode.of("RegionName", input.Region).withName("Region");
        bodyNode.addChildNode(node);
    }
    if (input.TrafficDialPercentage != null) {
        const node = __XmlNode
            .of("TrafficDialPercentage", String(input.TrafficDialPercentage))
            .withName("TrafficDialPercentage");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_NoncurrentVersionExpiration = (input, context) => {
    const bodyNode = new __XmlNode("NoncurrentVersionExpiration");
    if (input.NoncurrentDays != null) {
        const node = __XmlNode.of("Days", String(input.NoncurrentDays)).withName("NoncurrentDays");
        bodyNode.addChildNode(node);
    }
    if (input.NewerNoncurrentVersions != null) {
        const node = __XmlNode
            .of("NoncurrentVersionCount", String(input.NewerNoncurrentVersions))
            .withName("NewerNoncurrentVersions");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_NoncurrentVersionTransition = (input, context) => {
    const bodyNode = new __XmlNode("NoncurrentVersionTransition");
    if (input.NoncurrentDays != null) {
        const node = __XmlNode.of("Days", String(input.NoncurrentDays)).withName("NoncurrentDays");
        bodyNode.addChildNode(node);
    }
    if (input.StorageClass != null) {
        const node = __XmlNode.of("TransitionStorageClass", input.StorageClass).withName("StorageClass");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_NoncurrentVersionTransitionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_NoncurrentVersionTransition(entry, context);
        return node.withName("NoncurrentVersionTransition");
    });
};
const se_NonEmptyMaxLength1024StringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", entry);
        return node.withName("member");
    });
};
const se_ObjectLambdaAllowedFeaturesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("ObjectLambdaAllowedFeature", entry);
        return node.withName("AllowedFeature");
    });
};
const se_ObjectLambdaConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("ObjectLambdaConfiguration");
    if (input.SupportingAccessPoint != null) {
        const node = __XmlNode
            .of("ObjectLambdaSupportingAccessPointArn", input.SupportingAccessPoint)
            .withName("SupportingAccessPoint");
        bodyNode.addChildNode(node);
    }
    if (input.CloudWatchMetricsEnabled != null) {
        const node = __XmlNode.of("Boolean", String(input.CloudWatchMetricsEnabled)).withName("CloudWatchMetricsEnabled");
        bodyNode.addChildNode(node);
    }
    if (input.AllowedFeatures != null) {
        const nodes = se_ObjectLambdaAllowedFeaturesList(input.AllowedFeatures, context);
        const containerNode = new __XmlNode("AllowedFeatures");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.TransformationConfigurations != null) {
        const nodes = se_ObjectLambdaTransformationConfigurationsList(input.TransformationConfigurations, context);
        const containerNode = new __XmlNode("TransformationConfigurations");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_ObjectLambdaContentTransformation = (input, context) => {
    const bodyNode = new __XmlNode("ObjectLambdaContentTransformation");
    ObjectLambdaContentTransformation.visit(input, {
        AwsLambda: (value) => {
            const node = se_AwsLambdaTransformation(value, context).withName("AwsLambda");
            bodyNode.addChildNode(node);
        },
        _: (name, value) => {
            if (!(value instanceof __XmlNode || value instanceof __XmlText)) {
                throw new Error("Unable to serialize unknown union members in XML.");
            }
            bodyNode.addChildNode(new __XmlNode(name).addChildNode(value));
        },
    });
    return bodyNode;
};
const se_ObjectLambdaTransformationConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("ObjectLambdaTransformationConfiguration");
    if (input.Actions != null) {
        const nodes = se_ObjectLambdaTransformationConfigurationActionsList(input.Actions, context);
        const containerNode = new __XmlNode("Actions");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.ContentTransformation != null) {
        const node = se_ObjectLambdaContentTransformation(input.ContentTransformation, context).withName("ContentTransformation");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ObjectLambdaTransformationConfigurationActionsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("ObjectLambdaTransformationConfigurationAction", entry);
        return node.withName("Action");
    });
};
const se_ObjectLambdaTransformationConfigurationsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_ObjectLambdaTransformationConfiguration(entry, context);
        return node.withName("TransformationConfiguration");
    });
};
const se_PrefixLevel = (input, context) => {
    const bodyNode = new __XmlNode("PrefixLevel");
    if (input.StorageMetrics != null) {
        const node = se_PrefixLevelStorageMetrics(input.StorageMetrics, context).withName("StorageMetrics");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_PrefixLevelStorageMetrics = (input, context) => {
    const bodyNode = new __XmlNode("PrefixLevelStorageMetrics");
    if (input.IsEnabled != null) {
        const node = __XmlNode.of("IsEnabled", String(input.IsEnabled)).withName("IsEnabled");
        bodyNode.addChildNode(node);
    }
    if (input.SelectionCriteria != null) {
        const node = se_SelectionCriteria(input.SelectionCriteria, context).withName("SelectionCriteria");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_PublicAccessBlockConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("PublicAccessBlockConfiguration");
    if (input.BlockPublicAcls != null) {
        const node = __XmlNode.of("Setting", String(input.BlockPublicAcls)).withName("BlockPublicAcls");
        bodyNode.addChildNode(node);
    }
    if (input.IgnorePublicAcls != null) {
        const node = __XmlNode.of("Setting", String(input.IgnorePublicAcls)).withName("IgnorePublicAcls");
        bodyNode.addChildNode(node);
    }
    if (input.BlockPublicPolicy != null) {
        const node = __XmlNode.of("Setting", String(input.BlockPublicPolicy)).withName("BlockPublicPolicy");
        bodyNode.addChildNode(node);
    }
    if (input.RestrictPublicBuckets != null) {
        const node = __XmlNode.of("Setting", String(input.RestrictPublicBuckets)).withName("RestrictPublicBuckets");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_PutMultiRegionAccessPointPolicyInput = (input, context) => {
    const bodyNode = new __XmlNode("PutMultiRegionAccessPointPolicyInput");
    if (input.Name != null) {
        const node = __XmlNode.of("MultiRegionAccessPointName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.Policy != null) {
        const node = __XmlNode.of("Policy", input.Policy).withName("Policy");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Region = (input, context) => {
    const bodyNode = new __XmlNode("Region");
    if (input.Bucket != null) {
        const node = __XmlNode.of("BucketName", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    if (input.BucketAccountId != null) {
        const node = __XmlNode.of("AccountId", input.BucketAccountId).withName("BucketAccountId");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_RegionCreationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_Region(entry, context);
        return node.withName("Region");
    });
};
const se_Regions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("S3AWSRegion", entry);
        return node.withName("Region");
    });
};
const se_ReplicaModifications = (input, context) => {
    const bodyNode = new __XmlNode("ReplicaModifications");
    if (input.Status != null) {
        const node = __XmlNode.of("ReplicaModificationsStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ReplicationConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("ReplicationConfiguration");
    if (input.Role != null) {
        const node = __XmlNode.of("Role", input.Role).withName("Role");
        bodyNode.addChildNode(node);
    }
    if (input.Rules != null) {
        const nodes = se_ReplicationRules(input.Rules, context);
        const containerNode = new __XmlNode("Rules");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_ReplicationRule = (input, context) => {
    const bodyNode = new __XmlNode("ReplicationRule");
    if (input.ID != null) {
        const node = __XmlNode.of("ID", input.ID).withName("ID");
        bodyNode.addChildNode(node);
    }
    if (input.Priority != null) {
        const node = __XmlNode.of("Priority", String(input.Priority)).withName("Priority");
        bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
        const node = __XmlNode.of("Prefix", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
        const node = se_ReplicationRuleFilter(input.Filter, context).withName("Filter");
        bodyNode.addChildNode(node);
    }
    if (input.Status != null) {
        const node = __XmlNode.of("ReplicationRuleStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    if (input.SourceSelectionCriteria != null) {
        const node = se_SourceSelectionCriteria(input.SourceSelectionCriteria, context).withName("SourceSelectionCriteria");
        bodyNode.addChildNode(node);
    }
    if (input.ExistingObjectReplication != null) {
        const node = se_ExistingObjectReplication(input.ExistingObjectReplication, context).withName("ExistingObjectReplication");
        bodyNode.addChildNode(node);
    }
    if (input.Destination != null) {
        const node = se_Destination(input.Destination, context).withName("Destination");
        bodyNode.addChildNode(node);
    }
    if (input.DeleteMarkerReplication != null) {
        const node = se_DeleteMarkerReplication(input.DeleteMarkerReplication, context).withName("DeleteMarkerReplication");
        bodyNode.addChildNode(node);
    }
    if (input.Bucket != null) {
        const node = __XmlNode.of("BucketIdentifierString", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ReplicationRuleAndOperator = (input, context) => {
    const bodyNode = new __XmlNode("ReplicationRuleAndOperator");
    if (input.Prefix != null) {
        const node = __XmlNode.of("Prefix", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    if (input.Tags != null) {
        const nodes = se_S3TagSet(input.Tags, context);
        const containerNode = new __XmlNode("Tags");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_ReplicationRuleFilter = (input, context) => {
    const bodyNode = new __XmlNode("ReplicationRuleFilter");
    if (input.Prefix != null) {
        const node = __XmlNode.of("Prefix", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    if (input.Tag != null) {
        const node = se_S3Tag(input.Tag, context).withName("Tag");
        bodyNode.addChildNode(node);
    }
    if (input.And != null) {
        const node = se_ReplicationRuleAndOperator(input.And, context).withName("And");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ReplicationRules = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_ReplicationRule(entry, context);
        return node.withName("Rule");
    });
};
const se_ReplicationStatusFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("ReplicationStatus", entry);
        return node.withName("member");
    });
};
const se_ReplicationTime = (input, context) => {
    const bodyNode = new __XmlNode("ReplicationTime");
    if (input.Status != null) {
        const node = __XmlNode.of("ReplicationTimeStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    if (input.Time != null) {
        const node = se_ReplicationTimeValue(input.Time, context).withName("Time");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_ReplicationTimeValue = (input, context) => {
    const bodyNode = new __XmlNode("ReplicationTimeValue");
    if (input.Minutes != null) {
        const node = __XmlNode.of("Minutes", String(input.Minutes)).withName("Minutes");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_RouteList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_MultiRegionAccessPointRoute(entry, context);
        return node.withName("Route");
    });
};
const se_S3AccessControlList = (input, context) => {
    const bodyNode = new __XmlNode("S3AccessControlList");
    if (input.Owner != null) {
        const node = se_S3ObjectOwner(input.Owner, context).withName("Owner");
        bodyNode.addChildNode(node);
    }
    if (input.Grants != null) {
        const nodes = se_S3GrantList(input.Grants, context);
        const containerNode = new __XmlNode("Grants");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_S3AccessControlPolicy = (input, context) => {
    const bodyNode = new __XmlNode("S3AccessControlPolicy");
    if (input.AccessControlList != null) {
        const node = se_S3AccessControlList(input.AccessControlList, context).withName("AccessControlList");
        bodyNode.addChildNode(node);
    }
    if (input.CannedAccessControlList != null) {
        const node = __XmlNode
            .of("S3CannedAccessControlList", input.CannedAccessControlList)
            .withName("CannedAccessControlList");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3BucketDestination = (input, context) => {
    const bodyNode = new __XmlNode("S3BucketDestination");
    if (input.Format != null) {
        const node = __XmlNode.of("Format", input.Format).withName("Format");
        bodyNode.addChildNode(node);
    }
    if (input.OutputSchemaVersion != null) {
        const node = __XmlNode.of("OutputSchemaVersion", input.OutputSchemaVersion).withName("OutputSchemaVersion");
        bodyNode.addChildNode(node);
    }
    if (input.AccountId != null) {
        const node = __XmlNode.of("AccountId", input.AccountId).withName("AccountId");
        bodyNode.addChildNode(node);
    }
    if (input.Arn != null) {
        const node = __XmlNode.of("S3BucketArnString", input.Arn).withName("Arn");
        bodyNode.addChildNode(node);
    }
    if (input.Prefix != null) {
        const node = __XmlNode.of("Prefix", input.Prefix).withName("Prefix");
        bodyNode.addChildNode(node);
    }
    if (input.Encryption != null) {
        const node = se_StorageLensDataExportEncryption(input.Encryption, context).withName("Encryption");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3CopyObjectOperation = (input, context) => {
    const bodyNode = new __XmlNode("S3CopyObjectOperation");
    if (input.TargetResource != null) {
        const node = __XmlNode.of("S3RegionalOrS3ExpressBucketArnString", input.TargetResource).withName("TargetResource");
        bodyNode.addChildNode(node);
    }
    if (input.CannedAccessControlList != null) {
        const node = __XmlNode
            .of("S3CannedAccessControlList", input.CannedAccessControlList)
            .withName("CannedAccessControlList");
        bodyNode.addChildNode(node);
    }
    if (input.AccessControlGrants != null) {
        const nodes = se_S3GrantList(input.AccessControlGrants, context);
        const containerNode = new __XmlNode("AccessControlGrants");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MetadataDirective != null) {
        const node = __XmlNode.of("S3MetadataDirective", input.MetadataDirective).withName("MetadataDirective");
        bodyNode.addChildNode(node);
    }
    if (input.ModifiedSinceConstraint != null) {
        const node = __XmlNode
            .of("TimeStamp", input.ModifiedSinceConstraint.toISOString().split(".")[0] + "Z")
            .withName("ModifiedSinceConstraint");
        bodyNode.addChildNode(node);
    }
    if (input.NewObjectMetadata != null) {
        const node = se_S3ObjectMetadata(input.NewObjectMetadata, context).withName("NewObjectMetadata");
        bodyNode.addChildNode(node);
    }
    if (input.NewObjectTagging != null) {
        const nodes = se_S3TagSet(input.NewObjectTagging, context);
        const containerNode = new __XmlNode("NewObjectTagging");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.RedirectLocation != null) {
        const node = __XmlNode.of("NonEmptyMaxLength2048String", input.RedirectLocation).withName("RedirectLocation");
        bodyNode.addChildNode(node);
    }
    if (input.RequesterPays != null) {
        const node = __XmlNode.of("Boolean", String(input.RequesterPays)).withName("RequesterPays");
        bodyNode.addChildNode(node);
    }
    if (input.StorageClass != null) {
        const node = __XmlNode.of("S3StorageClass", input.StorageClass).withName("StorageClass");
        bodyNode.addChildNode(node);
    }
    if (input.UnModifiedSinceConstraint != null) {
        const node = __XmlNode
            .of("TimeStamp", input.UnModifiedSinceConstraint.toISOString().split(".")[0] + "Z")
            .withName("UnModifiedSinceConstraint");
        bodyNode.addChildNode(node);
    }
    if (input.SSEAwsKmsKeyId != null) {
        const node = __XmlNode.of("KmsKeyArnString", input.SSEAwsKmsKeyId).withName("SSEAwsKmsKeyId");
        bodyNode.addChildNode(node);
    }
    if (input.TargetKeyPrefix != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.TargetKeyPrefix).withName("TargetKeyPrefix");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectLockLegalHoldStatus != null) {
        const node = __XmlNode
            .of("S3ObjectLockLegalHoldStatus", input.ObjectLockLegalHoldStatus)
            .withName("ObjectLockLegalHoldStatus");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectLockMode != null) {
        const node = __XmlNode.of("S3ObjectLockMode", input.ObjectLockMode).withName("ObjectLockMode");
        bodyNode.addChildNode(node);
    }
    if (input.ObjectLockRetainUntilDate != null) {
        const node = __XmlNode
            .of("TimeStamp", input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z")
            .withName("ObjectLockRetainUntilDate");
        bodyNode.addChildNode(node);
    }
    if (input.BucketKeyEnabled != null) {
        const node = __XmlNode.of("Boolean", String(input.BucketKeyEnabled)).withName("BucketKeyEnabled");
        bodyNode.addChildNode(node);
    }
    if (input.ChecksumAlgorithm != null) {
        const node = __XmlNode.of("S3ChecksumAlgorithm", input.ChecksumAlgorithm).withName("ChecksumAlgorithm");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3DeleteObjectTaggingOperation = (input, context) => {
    const bodyNode = new __XmlNode("S3DeleteObjectTaggingOperation");
    return bodyNode;
};
const se_S3Grant = (input, context) => {
    const bodyNode = new __XmlNode("S3Grant");
    if (input.Grantee != null) {
        const node = se_S3Grantee(input.Grantee, context).withName("Grantee");
        bodyNode.addChildNode(node);
    }
    if (input.Permission != null) {
        const node = __XmlNode.of("S3Permission", input.Permission).withName("Permission");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3Grantee = (input, context) => {
    const bodyNode = new __XmlNode("S3Grantee");
    if (input.TypeIdentifier != null) {
        const node = __XmlNode.of("S3GranteeTypeIdentifier", input.TypeIdentifier).withName("TypeIdentifier");
        bodyNode.addChildNode(node);
    }
    if (input.Identifier != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.Identifier).withName("Identifier");
        bodyNode.addChildNode(node);
    }
    if (input.DisplayName != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.DisplayName).withName("DisplayName");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3GrantList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_S3Grant(entry, context);
        return node.withName("member");
    });
};
const se_S3InitiateRestoreObjectOperation = (input, context) => {
    const bodyNode = new __XmlNode("S3InitiateRestoreObjectOperation");
    if (input.ExpirationInDays != null) {
        const node = __XmlNode.of("S3ExpirationInDays", String(input.ExpirationInDays)).withName("ExpirationInDays");
        bodyNode.addChildNode(node);
    }
    if (input.GlacierJobTier != null) {
        const node = __XmlNode.of("S3GlacierJobTier", input.GlacierJobTier).withName("GlacierJobTier");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3JobManifestGenerator = (input, context) => {
    const bodyNode = new __XmlNode("S3JobManifestGenerator");
    if (input.ExpectedBucketOwner != null) {
        const node = __XmlNode.of("AccountId", input.ExpectedBucketOwner).withName("ExpectedBucketOwner");
        bodyNode.addChildNode(node);
    }
    if (input.SourceBucket != null) {
        const node = __XmlNode.of("S3BucketArnString", input.SourceBucket).withName("SourceBucket");
        bodyNode.addChildNode(node);
    }
    if (input.ManifestOutputLocation != null) {
        const node = se_S3ManifestOutputLocation(input.ManifestOutputLocation, context).withName("ManifestOutputLocation");
        bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
        const node = se_JobManifestGeneratorFilter(input.Filter, context).withName("Filter");
        bodyNode.addChildNode(node);
    }
    if (input.EnableManifestOutput != null) {
        const node = __XmlNode.of("Boolean", String(input.EnableManifestOutput)).withName("EnableManifestOutput");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3ManifestOutputLocation = (input, context) => {
    const bodyNode = new __XmlNode("S3ManifestOutputLocation");
    if (input.ExpectedManifestBucketOwner != null) {
        const node = __XmlNode.of("AccountId", input.ExpectedManifestBucketOwner).withName("ExpectedManifestBucketOwner");
        bodyNode.addChildNode(node);
    }
    if (input.Bucket != null) {
        const node = __XmlNode.of("S3BucketArnString", input.Bucket).withName("Bucket");
        bodyNode.addChildNode(node);
    }
    if (input.ManifestPrefix != null) {
        const node = __XmlNode.of("ManifestPrefixString", input.ManifestPrefix).withName("ManifestPrefix");
        bodyNode.addChildNode(node);
    }
    if (input.ManifestEncryption != null) {
        const node = se_GeneratedManifestEncryption(input.ManifestEncryption, context).withName("ManifestEncryption");
        bodyNode.addChildNode(node);
    }
    if (input.ManifestFormat != null) {
        const node = __XmlNode.of("GeneratedManifestFormat", input.ManifestFormat).withName("ManifestFormat");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3ObjectLockLegalHold = (input, context) => {
    const bodyNode = new __XmlNode("S3ObjectLockLegalHold");
    if (input.Status != null) {
        const node = __XmlNode.of("S3ObjectLockLegalHoldStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3ObjectMetadata = (input, context) => {
    const bodyNode = new __XmlNode("S3ObjectMetadata");
    if (input.CacheControl != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.CacheControl).withName("CacheControl");
        bodyNode.addChildNode(node);
    }
    if (input.ContentDisposition != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.ContentDisposition).withName("ContentDisposition");
        bodyNode.addChildNode(node);
    }
    if (input.ContentEncoding != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.ContentEncoding).withName("ContentEncoding");
        bodyNode.addChildNode(node);
    }
    if (input.ContentLanguage != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.ContentLanguage).withName("ContentLanguage");
        bodyNode.addChildNode(node);
    }
    if (input.UserMetadata != null) {
        const nodes = se_S3UserMetadata(input.UserMetadata, context);
        const containerNode = new __XmlNode("UserMetadata");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.ContentLength != null) {
        const node = __XmlNode.of("S3ContentLength", String(input.ContentLength)).withName("ContentLength");
        bodyNode.addChildNode(node);
    }
    if (input.ContentMD5 != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.ContentMD5).withName("ContentMD5");
        bodyNode.addChildNode(node);
    }
    if (input.ContentType != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.ContentType).withName("ContentType");
        bodyNode.addChildNode(node);
    }
    if (input.HttpExpiresDate != null) {
        const node = __XmlNode
            .of("TimeStamp", input.HttpExpiresDate.toISOString().split(".")[0] + "Z")
            .withName("HttpExpiresDate");
        bodyNode.addChildNode(node);
    }
    if (input.RequesterCharged != null) {
        const node = __XmlNode.of("Boolean", String(input.RequesterCharged)).withName("RequesterCharged");
        bodyNode.addChildNode(node);
    }
    if (input.SSEAlgorithm != null) {
        const node = __XmlNode.of("S3SSEAlgorithm", input.SSEAlgorithm).withName("SSEAlgorithm");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3ObjectOwner = (input, context) => {
    const bodyNode = new __XmlNode("S3ObjectOwner");
    if (input.ID != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.ID).withName("ID");
        bodyNode.addChildNode(node);
    }
    if (input.DisplayName != null) {
        const node = __XmlNode.of("NonEmptyMaxLength1024String", input.DisplayName).withName("DisplayName");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3ReplicateObjectOperation = (input, context) => {
    const bodyNode = new __XmlNode("S3ReplicateObjectOperation");
    return bodyNode;
};
const se_S3Retention = (input, context) => {
    const bodyNode = new __XmlNode("S3Retention");
    if (input.RetainUntilDate != null) {
        const node = __XmlNode
            .of("TimeStamp", input.RetainUntilDate.toISOString().split(".")[0] + "Z")
            .withName("RetainUntilDate");
        bodyNode.addChildNode(node);
    }
    if (input.Mode != null) {
        const node = __XmlNode.of("S3ObjectLockRetentionMode", input.Mode).withName("Mode");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3SetObjectAclOperation = (input, context) => {
    const bodyNode = new __XmlNode("S3SetObjectAclOperation");
    if (input.AccessControlPolicy != null) {
        const node = se_S3AccessControlPolicy(input.AccessControlPolicy, context).withName("AccessControlPolicy");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3SetObjectLegalHoldOperation = (input, context) => {
    const bodyNode = new __XmlNode("S3SetObjectLegalHoldOperation");
    if (input.LegalHold != null) {
        const node = se_S3ObjectLockLegalHold(input.LegalHold, context).withName("LegalHold");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3SetObjectRetentionOperation = (input, context) => {
    const bodyNode = new __XmlNode("S3SetObjectRetentionOperation");
    if (input.BypassGovernanceRetention != null) {
        const node = __XmlNode.of("Boolean", String(input.BypassGovernanceRetention)).withName("BypassGovernanceRetention");
        bodyNode.addChildNode(node);
    }
    if (input.Retention != null) {
        const node = se_S3Retention(input.Retention, context).withName("Retention");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3SetObjectTaggingOperation = (input, context) => {
    const bodyNode = new __XmlNode("S3SetObjectTaggingOperation");
    if (input.TagSet != null) {
        const nodes = se_S3TagSet(input.TagSet, context);
        const containerNode = new __XmlNode("TagSet");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_S3Tag = (input, context) => {
    const bodyNode = new __XmlNode("S3Tag");
    if (input.Key != null) {
        const node = __XmlNode.of("TagKeyString", input.Key).withName("Key");
        bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
        const node = __XmlNode.of("TagValueString", input.Value).withName("Value");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_S3TagSet = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_S3Tag(entry, context);
        return node.withName("member");
    });
};
const se_S3UserMetadata = (input, context) => {
    return Object.keys(input)
        .filter((key) => input[key] != null)
        .map((key) => {
        const entryNode = new __XmlNode("entry");
        const keyNode = __XmlNode.of("NonEmptyMaxLength1024String", key).withName("key");
        entryNode.addChildNode(keyNode);
        let node;
        node = __XmlNode.of("MaxLength1024String", input[key]);
        entryNode.addChildNode(node.withName("value"));
        return entryNode;
    });
};
const se_SelectionCriteria = (input, context) => {
    const bodyNode = new __XmlNode("SelectionCriteria");
    if (input.Delimiter != null) {
        const node = __XmlNode.of("StorageLensPrefixLevelDelimiter", input.Delimiter).withName("Delimiter");
        bodyNode.addChildNode(node);
    }
    if (input.MaxDepth != null) {
        const node = __XmlNode.of("StorageLensPrefixLevelMaxDepth", String(input.MaxDepth)).withName("MaxDepth");
        bodyNode.addChildNode(node);
    }
    if (input.MinStorageBytesPercentage != null) {
        const node = __XmlNode
            .of("MinStorageBytesPercentage", String(input.MinStorageBytesPercentage))
            .withName("MinStorageBytesPercentage");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_SourceSelectionCriteria = (input, context) => {
    const bodyNode = new __XmlNode("SourceSelectionCriteria");
    if (input.SseKmsEncryptedObjects != null) {
        const node = se_SseKmsEncryptedObjects(input.SseKmsEncryptedObjects, context).withName("SseKmsEncryptedObjects");
        bodyNode.addChildNode(node);
    }
    if (input.ReplicaModifications != null) {
        const node = se_ReplicaModifications(input.ReplicaModifications, context).withName("ReplicaModifications");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_SSEKMS = (input, context) => {
    const bodyNode = new __XmlNode("SSE-KMS");
    if (input.KeyId != null) {
        const node = __XmlNode.of("SSEKMSKeyId", input.KeyId).withName("KeyId");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_SseKmsEncryptedObjects = (input, context) => {
    const bodyNode = new __XmlNode("SseKmsEncryptedObjects");
    if (input.Status != null) {
        const node = __XmlNode.of("SseKmsEncryptedObjectsStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_SSEKMSEncryption = (input, context) => {
    const bodyNode = new __XmlNode("SSE-KMS");
    if (input.KeyId != null) {
        const node = __XmlNode.of("KmsKeyArnString", input.KeyId).withName("KeyId");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_SSES3 = (input, context) => {
    const bodyNode = new __XmlNode("SSE-S3");
    return bodyNode;
};
const se_SSES3Encryption = (input, context) => {
    const bodyNode = new __XmlNode("SSE-S3");
    return bodyNode;
};
const se_StorageClassList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("S3StorageClass", entry);
        return node.withName("member");
    });
};
const se_StorageLensAwsOrg = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensAwsOrg");
    if (input.Arn != null) {
        const node = __XmlNode.of("AwsOrgArn", input.Arn).withName("Arn");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensConfiguration");
    if (input.Id != null) {
        const node = __XmlNode.of("ConfigId", input.Id).withName("Id");
        bodyNode.addChildNode(node);
    }
    if (input.AccountLevel != null) {
        const node = se_AccountLevel(input.AccountLevel, context).withName("AccountLevel");
        bodyNode.addChildNode(node);
    }
    if (input.Include != null) {
        const node = se_Include(input.Include, context).withName("Include");
        bodyNode.addChildNode(node);
    }
    if (input.Exclude != null) {
        const node = se__Exclude(input.Exclude, context).withName("Exclude");
        bodyNode.addChildNode(node);
    }
    if (input.DataExport != null) {
        const node = se_StorageLensDataExport(input.DataExport, context).withName("DataExport");
        bodyNode.addChildNode(node);
    }
    if (input.IsEnabled != null) {
        const node = __XmlNode.of("IsEnabled", String(input.IsEnabled)).withName("IsEnabled");
        bodyNode.addChildNode(node);
    }
    if (input.AwsOrg != null) {
        const node = se_StorageLensAwsOrg(input.AwsOrg, context).withName("AwsOrg");
        bodyNode.addChildNode(node);
    }
    if (input.StorageLensArn != null) {
        const node = __XmlNode.of("StorageLensArn", input.StorageLensArn).withName("StorageLensArn");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensDataExport = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensDataExport");
    if (input.S3BucketDestination != null) {
        const node = se_S3BucketDestination(input.S3BucketDestination, context).withName("S3BucketDestination");
        bodyNode.addChildNode(node);
    }
    if (input.CloudWatchMetrics != null) {
        const node = se_CloudWatchMetrics(input.CloudWatchMetrics, context).withName("CloudWatchMetrics");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensDataExportEncryption = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensDataExportEncryption");
    if (input.SSES3 != null) {
        const node = se_SSES3(input.SSES3, context).withName("SSE-S3");
        bodyNode.addChildNode(node);
    }
    if (input.SSEKMS != null) {
        const node = se_SSEKMS(input.SSEKMS, context).withName("SSE-KMS");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensGroup = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensGroup");
    if (input.Name != null) {
        const node = __XmlNode.of("StorageLensGroupName", input.Name).withName("Name");
        bodyNode.addChildNode(node);
    }
    if (input.Filter != null) {
        const node = se_StorageLensGroupFilter(input.Filter, context).withName("Filter");
        bodyNode.addChildNode(node);
    }
    if (input.StorageLensGroupArn != null) {
        const node = __XmlNode.of("StorageLensGroupArn", input.StorageLensGroupArn).withName("StorageLensGroupArn");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensGroupAndOperator = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensGroupAndOperator");
    if (input.MatchAnyPrefix != null) {
        const nodes = se_MatchAnyPrefix(input.MatchAnyPrefix, context);
        const containerNode = new __XmlNode("MatchAnyPrefix");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchAnySuffix != null) {
        const nodes = se_MatchAnySuffix(input.MatchAnySuffix, context);
        const containerNode = new __XmlNode("MatchAnySuffix");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchAnyTag != null) {
        const nodes = se_MatchAnyTag(input.MatchAnyTag, context);
        const containerNode = new __XmlNode("MatchAnyTag");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchObjectAge != null) {
        const node = se_MatchObjectAge(input.MatchObjectAge, context).withName("MatchObjectAge");
        bodyNode.addChildNode(node);
    }
    if (input.MatchObjectSize != null) {
        const node = se_MatchObjectSize(input.MatchObjectSize, context).withName("MatchObjectSize");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensGroupFilter = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensGroupFilter");
    if (input.MatchAnyPrefix != null) {
        const nodes = se_MatchAnyPrefix(input.MatchAnyPrefix, context);
        const containerNode = new __XmlNode("MatchAnyPrefix");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchAnySuffix != null) {
        const nodes = se_MatchAnySuffix(input.MatchAnySuffix, context);
        const containerNode = new __XmlNode("MatchAnySuffix");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchAnyTag != null) {
        const nodes = se_MatchAnyTag(input.MatchAnyTag, context);
        const containerNode = new __XmlNode("MatchAnyTag");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchObjectAge != null) {
        const node = se_MatchObjectAge(input.MatchObjectAge, context).withName("MatchObjectAge");
        bodyNode.addChildNode(node);
    }
    if (input.MatchObjectSize != null) {
        const node = se_MatchObjectSize(input.MatchObjectSize, context).withName("MatchObjectSize");
        bodyNode.addChildNode(node);
    }
    if (input.And != null) {
        const node = se_StorageLensGroupAndOperator(input.And, context).withName("And");
        bodyNode.addChildNode(node);
    }
    if (input.Or != null) {
        const node = se_StorageLensGroupOrOperator(input.Or, context).withName("Or");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensGroupLevel = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensGroupLevel");
    if (input.SelectionCriteria != null) {
        const node = se_StorageLensGroupLevelSelectionCriteria(input.SelectionCriteria, context).withName("SelectionCriteria");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensGroupLevelExclude = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("StorageLensGroupArn", entry);
        return node.withName("Arn");
    });
};
const se_StorageLensGroupLevelInclude = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = __XmlNode.of("StorageLensGroupArn", entry);
        return node.withName("Arn");
    });
};
const se_StorageLensGroupLevelSelectionCriteria = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensGroupLevelSelectionCriteria");
    if (input.Include != null) {
        const nodes = se_StorageLensGroupLevelInclude(input.Include, context);
        const containerNode = new __XmlNode("Include");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.Exclude != null) {
        const nodes = se_StorageLensGroupLevelExclude(input.Exclude, context);
        const containerNode = new __XmlNode("Exclude");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_StorageLensGroupOrOperator = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensGroupOrOperator");
    if (input.MatchAnyPrefix != null) {
        const nodes = se_MatchAnyPrefix(input.MatchAnyPrefix, context);
        const containerNode = new __XmlNode("MatchAnyPrefix");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchAnySuffix != null) {
        const nodes = se_MatchAnySuffix(input.MatchAnySuffix, context);
        const containerNode = new __XmlNode("MatchAnySuffix");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchAnyTag != null) {
        const nodes = se_MatchAnyTag(input.MatchAnyTag, context);
        const containerNode = new __XmlNode("MatchAnyTag");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    if (input.MatchObjectAge != null) {
        const node = se_MatchObjectAge(input.MatchObjectAge, context).withName("MatchObjectAge");
        bodyNode.addChildNode(node);
    }
    if (input.MatchObjectSize != null) {
        const node = se_MatchObjectSize(input.MatchObjectSize, context).withName("MatchObjectSize");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensTag = (input, context) => {
    const bodyNode = new __XmlNode("StorageLensTag");
    if (input.Key != null) {
        const node = __XmlNode.of("TagKeyString", input.Key).withName("Key");
        bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
        const node = __XmlNode.of("TagValueString", input.Value).withName("Value");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_StorageLensTags = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_StorageLensTag(entry, context);
        return node.withName("Tag");
    });
};
const se_Tag = (input, context) => {
    const bodyNode = new __XmlNode("Tag");
    if (input.Key != null) {
        const node = __XmlNode.of("TagKeyString", input.Key).withName("Key");
        bodyNode.addChildNode(node);
    }
    if (input.Value != null) {
        const node = __XmlNode.of("TagValueString", input.Value).withName("Value");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_Tagging = (input, context) => {
    const bodyNode = new __XmlNode("Tagging");
    if (input.TagSet != null) {
        const nodes = se_S3TagSet(input.TagSet, context);
        const containerNode = new __XmlNode("TagSet");
        nodes.map((node) => {
            containerNode.addChildNode(node);
        });
        bodyNode.addChildNode(containerNode);
    }
    return bodyNode;
};
const se_TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_Tag(entry, context);
        return node.withName("Tag");
    });
};
const se_Transition = (input, context) => {
    const bodyNode = new __XmlNode("Transition");
    if (input.Date != null) {
        const node = __XmlNode.of("Date", input.Date.toISOString().split(".")[0] + "Z").withName("Date");
        bodyNode.addChildNode(node);
    }
    if (input.Days != null) {
        const node = __XmlNode.of("Days", String(input.Days)).withName("Days");
        bodyNode.addChildNode(node);
    }
    if (input.StorageClass != null) {
        const node = __XmlNode.of("TransitionStorageClass", input.StorageClass).withName("StorageClass");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_TransitionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const node = se_Transition(entry, context);
        return node.withName("Transition");
    });
};
const se_UserArguments = (input, context) => {
    return Object.keys(input)
        .filter((key) => input[key] != null)
        .map((key) => {
        const entryNode = new __XmlNode("entry");
        const keyNode = __XmlNode.of("NonEmptyMaxLength64String", key).withName("key");
        entryNode.addChildNode(keyNode);
        let node;
        node = __XmlNode.of("MaxLength1024String", input[key]);
        entryNode.addChildNode(node.withName("value"));
        return entryNode;
    });
};
const se_VersioningConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("VersioningConfiguration");
    if (input.MFADelete != null) {
        const node = __XmlNode.of("MFADelete", input.MFADelete).withName("MfaDelete");
        bodyNode.addChildNode(node);
    }
    if (input.Status != null) {
        const node = __XmlNode.of("BucketVersioningStatus", input.Status).withName("Status");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const se_VpcConfiguration = (input, context) => {
    const bodyNode = new __XmlNode("VpcConfiguration");
    if (input.VpcId != null) {
        const node = __XmlNode.of("VpcId", input.VpcId).withName("VpcId");
        bodyNode.addChildNode(node);
    }
    return bodyNode;
};
const de_AbortIncompleteMultipartUpload = (output, context) => {
    const contents = {};
    if (output["DaysAfterInitiation"] !== undefined) {
        contents.DaysAfterInitiation = __strictParseInt32(output["DaysAfterInitiation"]);
    }
    return contents;
};
const de_AccessControlTranslation = (output, context) => {
    const contents = {};
    if (output["Owner"] !== undefined) {
        contents.Owner = __expectString(output["Owner"]);
    }
    return contents;
};
const de_AccessGrantsInstancesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListAccessGrantsInstanceEntry(entry, context);
    });
};
const de_AccessGrantsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListAccessGrantEntry(entry, context);
    });
};
const de_AccessGrantsLocationConfiguration = (output, context) => {
    const contents = {};
    if (output["S3SubPrefix"] !== undefined) {
        contents.S3SubPrefix = __expectString(output["S3SubPrefix"]);
    }
    return contents;
};
const de_AccessGrantsLocationsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListAccessGrantsLocationsEntry(entry, context);
    });
};
const de_AccessPoint = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["NetworkOrigin"] !== undefined) {
        contents.NetworkOrigin = __expectString(output["NetworkOrigin"]);
    }
    if (output["VpcConfiguration"] !== undefined) {
        contents.VpcConfiguration = de_VpcConfiguration(output["VpcConfiguration"], context);
    }
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    if (output["AccessPointArn"] !== undefined) {
        contents.AccessPointArn = __expectString(output["AccessPointArn"]);
    }
    if (output["Alias"] !== undefined) {
        contents.Alias = __expectString(output["Alias"]);
    }
    if (output["BucketAccountId"] !== undefined) {
        contents.BucketAccountId = __expectString(output["BucketAccountId"]);
    }
    return contents;
};
const de_AccessPointList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessPoint(entry, context);
    });
};
const de_AccountLevel = (output, context) => {
    const contents = {};
    if (output["ActivityMetrics"] !== undefined) {
        contents.ActivityMetrics = de_ActivityMetrics(output["ActivityMetrics"], context);
    }
    if (output["BucketLevel"] !== undefined) {
        contents.BucketLevel = de_BucketLevel(output["BucketLevel"], context);
    }
    if (output["AdvancedCostOptimizationMetrics"] !== undefined) {
        contents.AdvancedCostOptimizationMetrics = de_AdvancedCostOptimizationMetrics(output["AdvancedCostOptimizationMetrics"], context);
    }
    if (output["AdvancedDataProtectionMetrics"] !== undefined) {
        contents.AdvancedDataProtectionMetrics = de_AdvancedDataProtectionMetrics(output["AdvancedDataProtectionMetrics"], context);
    }
    if (output["DetailedStatusCodesMetrics"] !== undefined) {
        contents.DetailedStatusCodesMetrics = de_DetailedStatusCodesMetrics(output["DetailedStatusCodesMetrics"], context);
    }
    if (output["StorageLensGroupLevel"] !== undefined) {
        contents.StorageLensGroupLevel = de_StorageLensGroupLevel(output["StorageLensGroupLevel"], context);
    }
    return contents;
};
const de_ActivityMetrics = (output, context) => {
    const contents = {};
    if (output["IsEnabled"] !== undefined) {
        contents.IsEnabled = __parseBoolean(output["IsEnabled"]);
    }
    return contents;
};
const de_AdvancedCostOptimizationMetrics = (output, context) => {
    const contents = {};
    if (output["IsEnabled"] !== undefined) {
        contents.IsEnabled = __parseBoolean(output["IsEnabled"]);
    }
    return contents;
};
const de_AdvancedDataProtectionMetrics = (output, context) => {
    const contents = {};
    if (output["IsEnabled"] !== undefined) {
        contents.IsEnabled = __parseBoolean(output["IsEnabled"]);
    }
    return contents;
};
const de_AsyncErrorDetails = (output, context) => {
    const contents = {};
    if (output["Code"] !== undefined) {
        contents.Code = __expectString(output["Code"]);
    }
    if (output["Message"] !== undefined) {
        contents.Message = __expectString(output["Message"]);
    }
    if (output["Resource"] !== undefined) {
        contents.Resource = __expectString(output["Resource"]);
    }
    if (output["RequestId"] !== undefined) {
        contents.RequestId = __expectString(output["RequestId"]);
    }
    return contents;
};
const de_AsyncOperation = (output, context) => {
    const contents = {};
    if (output["CreationTime"] !== undefined) {
        contents.CreationTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreationTime"]));
    }
    if (output["Operation"] !== undefined) {
        contents.Operation = __expectString(output["Operation"]);
    }
    if (output["RequestTokenARN"] !== undefined) {
        contents.RequestTokenARN = __expectString(output["RequestTokenARN"]);
    }
    if (output["RequestParameters"] !== undefined) {
        contents.RequestParameters = de_AsyncRequestParameters(output["RequestParameters"], context);
    }
    if (output["RequestStatus"] !== undefined) {
        contents.RequestStatus = __expectString(output["RequestStatus"]);
    }
    if (output["ResponseDetails"] !== undefined) {
        contents.ResponseDetails = de_AsyncResponseDetails(output["ResponseDetails"], context);
    }
    return contents;
};
const de_AsyncRequestParameters = (output, context) => {
    const contents = {};
    if (output["CreateMultiRegionAccessPointRequest"] !== undefined) {
        contents.CreateMultiRegionAccessPointRequest = de_CreateMultiRegionAccessPointInput(output["CreateMultiRegionAccessPointRequest"], context);
    }
    if (output["DeleteMultiRegionAccessPointRequest"] !== undefined) {
        contents.DeleteMultiRegionAccessPointRequest = de_DeleteMultiRegionAccessPointInput(output["DeleteMultiRegionAccessPointRequest"], context);
    }
    if (output["PutMultiRegionAccessPointPolicyRequest"] !== undefined) {
        contents.PutMultiRegionAccessPointPolicyRequest = de_PutMultiRegionAccessPointPolicyInput(output["PutMultiRegionAccessPointPolicyRequest"], context);
    }
    return contents;
};
const de_AsyncResponseDetails = (output, context) => {
    const contents = {};
    if (output["MultiRegionAccessPointDetails"] !== undefined) {
        contents.MultiRegionAccessPointDetails = de_MultiRegionAccessPointsAsyncResponse(output["MultiRegionAccessPointDetails"], context);
    }
    if (output["ErrorDetails"] !== undefined) {
        contents.ErrorDetails = de_AsyncErrorDetails(output["ErrorDetails"], context);
    }
    return contents;
};
const de_AwsLambdaTransformation = (output, context) => {
    const contents = {};
    if (output["FunctionArn"] !== undefined) {
        contents.FunctionArn = __expectString(output["FunctionArn"]);
    }
    if (output["FunctionPayload"] !== undefined) {
        contents.FunctionPayload = __expectString(output["FunctionPayload"]);
    }
    return contents;
};
const de_BucketLevel = (output, context) => {
    const contents = {};
    if (output["ActivityMetrics"] !== undefined) {
        contents.ActivityMetrics = de_ActivityMetrics(output["ActivityMetrics"], context);
    }
    if (output["PrefixLevel"] !== undefined) {
        contents.PrefixLevel = de_PrefixLevel(output["PrefixLevel"], context);
    }
    if (output["AdvancedCostOptimizationMetrics"] !== undefined) {
        contents.AdvancedCostOptimizationMetrics = de_AdvancedCostOptimizationMetrics(output["AdvancedCostOptimizationMetrics"], context);
    }
    if (output["AdvancedDataProtectionMetrics"] !== undefined) {
        contents.AdvancedDataProtectionMetrics = de_AdvancedDataProtectionMetrics(output["AdvancedDataProtectionMetrics"], context);
    }
    if (output["DetailedStatusCodesMetrics"] !== undefined) {
        contents.DetailedStatusCodesMetrics = de_DetailedStatusCodesMetrics(output["DetailedStatusCodesMetrics"], context);
    }
    return contents;
};
const de_Buckets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CloudWatchMetrics = (output, context) => {
    const contents = {};
    if (output["IsEnabled"] !== undefined) {
        contents.IsEnabled = __parseBoolean(output["IsEnabled"]);
    }
    return contents;
};
const de_CreateMultiRegionAccessPointInput = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["PublicAccessBlock"] !== undefined) {
        contents.PublicAccessBlock = de_PublicAccessBlockConfiguration(output["PublicAccessBlock"], context);
    }
    if (output.Regions === "") {
        contents.Regions = [];
    }
    else if (output["Regions"] !== undefined && output["Regions"]["Region"] !== undefined) {
        contents.Regions = de_RegionCreationList(__getArrayIfSingleItem(output["Regions"]["Region"]), context);
    }
    return contents;
};
const de_Credentials = (output, context) => {
    const contents = {};
    if (output["AccessKeyId"] !== undefined) {
        contents.AccessKeyId = __expectString(output["AccessKeyId"]);
    }
    if (output["SecretAccessKey"] !== undefined) {
        contents.SecretAccessKey = __expectString(output["SecretAccessKey"]);
    }
    if (output["SessionToken"] !== undefined) {
        contents.SessionToken = __expectString(output["SessionToken"]);
    }
    if (output["Expiration"] !== undefined) {
        contents.Expiration = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Expiration"]));
    }
    return contents;
};
const de_DeleteMarkerReplication = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    return contents;
};
const de_DeleteMultiRegionAccessPointInput = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    return contents;
};
const de_Destination = (output, context) => {
    const contents = {};
    if (output["Account"] !== undefined) {
        contents.Account = __expectString(output["Account"]);
    }
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    if (output["ReplicationTime"] !== undefined) {
        contents.ReplicationTime = de_ReplicationTime(output["ReplicationTime"], context);
    }
    if (output["AccessControlTranslation"] !== undefined) {
        contents.AccessControlTranslation = de_AccessControlTranslation(output["AccessControlTranslation"], context);
    }
    if (output["EncryptionConfiguration"] !== undefined) {
        contents.EncryptionConfiguration = de_EncryptionConfiguration(output["EncryptionConfiguration"], context);
    }
    if (output["Metrics"] !== undefined) {
        contents.Metrics = de_Metrics(output["Metrics"], context);
    }
    if (output["StorageClass"] !== undefined) {
        contents.StorageClass = __expectString(output["StorageClass"]);
    }
    return contents;
};
const de_DetailedStatusCodesMetrics = (output, context) => {
    const contents = {};
    if (output["IsEnabled"] !== undefined) {
        contents.IsEnabled = __parseBoolean(output["IsEnabled"]);
    }
    return contents;
};
const de_EncryptionConfiguration = (output, context) => {
    const contents = {};
    if (output["ReplicaKmsKeyID"] !== undefined) {
        contents.ReplicaKmsKeyID = __expectString(output["ReplicaKmsKeyID"]);
    }
    return contents;
};
const de_Endpoints = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_EstablishedMultiRegionAccessPointPolicy = (output, context) => {
    const contents = {};
    if (output["Policy"] !== undefined) {
        contents.Policy = __expectString(output["Policy"]);
    }
    return contents;
};
const de__Exclude = (output, context) => {
    const contents = {};
    if (output.Buckets === "") {
        contents.Buckets = [];
    }
    else if (output["Buckets"] !== undefined && output["Buckets"]["Arn"] !== undefined) {
        contents.Buckets = de_Buckets(__getArrayIfSingleItem(output["Buckets"]["Arn"]), context);
    }
    if (output.Regions === "") {
        contents.Regions = [];
    }
    else if (output["Regions"] !== undefined && output["Regions"]["Region"] !== undefined) {
        contents.Regions = de_Regions(__getArrayIfSingleItem(output["Regions"]["Region"]), context);
    }
    return contents;
};
const de_ExistingObjectReplication = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    return contents;
};
const de_GeneratedManifestEncryption = (output, context) => {
    const contents = {};
    if (output["SSE-S3"] !== undefined) {
        contents.SSES3 = de_SSES3Encryption(output["SSE-S3"], context);
    }
    if (output["SSE-KMS"] !== undefined) {
        contents.SSEKMS = de_SSEKMSEncryption(output["SSE-KMS"], context);
    }
    return contents;
};
const de_Grantee = (output, context) => {
    const contents = {};
    if (output["GranteeType"] !== undefined) {
        contents.GranteeType = __expectString(output["GranteeType"]);
    }
    if (output["GranteeIdentifier"] !== undefined) {
        contents.GranteeIdentifier = __expectString(output["GranteeIdentifier"]);
    }
    return contents;
};
const de_Include = (output, context) => {
    const contents = {};
    if (output.Buckets === "") {
        contents.Buckets = [];
    }
    else if (output["Buckets"] !== undefined && output["Buckets"]["Arn"] !== undefined) {
        contents.Buckets = de_Buckets(__getArrayIfSingleItem(output["Buckets"]["Arn"]), context);
    }
    if (output.Regions === "") {
        contents.Regions = [];
    }
    else if (output["Regions"] !== undefined && output["Regions"]["Region"] !== undefined) {
        contents.Regions = de_Regions(__getArrayIfSingleItem(output["Regions"]["Region"]), context);
    }
    return contents;
};
const de_JobDescriptor = (output, context) => {
    const contents = {};
    if (output["JobId"] !== undefined) {
        contents.JobId = __expectString(output["JobId"]);
    }
    if (output["ConfirmationRequired"] !== undefined) {
        contents.ConfirmationRequired = __parseBoolean(output["ConfirmationRequired"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = __expectString(output["Description"]);
    }
    if (output["JobArn"] !== undefined) {
        contents.JobArn = __expectString(output["JobArn"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["Manifest"] !== undefined) {
        contents.Manifest = de_JobManifest(output["Manifest"], context);
    }
    if (output["Operation"] !== undefined) {
        contents.Operation = de_JobOperation(output["Operation"], context);
    }
    if (output["Priority"] !== undefined) {
        contents.Priority = __strictParseInt32(output["Priority"]);
    }
    if (output["ProgressSummary"] !== undefined) {
        contents.ProgressSummary = de_JobProgressSummary(output["ProgressSummary"], context);
    }
    if (output["StatusUpdateReason"] !== undefined) {
        contents.StatusUpdateReason = __expectString(output["StatusUpdateReason"]);
    }
    if (output.FailureReasons === "") {
        contents.FailureReasons = [];
    }
    else if (output["FailureReasons"] !== undefined && output["FailureReasons"]["member"] !== undefined) {
        contents.FailureReasons = de_JobFailureList(__getArrayIfSingleItem(output["FailureReasons"]["member"]), context);
    }
    if (output["Report"] !== undefined) {
        contents.Report = de_JobReport(output["Report"], context);
    }
    if (output["CreationTime"] !== undefined) {
        contents.CreationTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreationTime"]));
    }
    if (output["TerminationDate"] !== undefined) {
        contents.TerminationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["TerminationDate"]));
    }
    if (output["RoleArn"] !== undefined) {
        contents.RoleArn = __expectString(output["RoleArn"]);
    }
    if (output["SuspendedDate"] !== undefined) {
        contents.SuspendedDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["SuspendedDate"]));
    }
    if (output["SuspendedCause"] !== undefined) {
        contents.SuspendedCause = __expectString(output["SuspendedCause"]);
    }
    if (output.ManifestGenerator === "") {
    }
    else if (output["ManifestGenerator"] !== undefined) {
        contents.ManifestGenerator = de_JobManifestGenerator(__expectUnion(output["ManifestGenerator"]), context);
    }
    if (output["GeneratedManifestDescriptor"] !== undefined) {
        contents.GeneratedManifestDescriptor = de_S3GeneratedManifestDescriptor(output["GeneratedManifestDescriptor"], context);
    }
    return contents;
};
const de_JobFailure = (output, context) => {
    const contents = {};
    if (output["FailureCode"] !== undefined) {
        contents.FailureCode = __expectString(output["FailureCode"]);
    }
    if (output["FailureReason"] !== undefined) {
        contents.FailureReason = __expectString(output["FailureReason"]);
    }
    return contents;
};
const de_JobFailureList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobFailure(entry, context);
    });
};
const de_JobListDescriptor = (output, context) => {
    const contents = {};
    if (output["JobId"] !== undefined) {
        contents.JobId = __expectString(output["JobId"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = __expectString(output["Description"]);
    }
    if (output["Operation"] !== undefined) {
        contents.Operation = __expectString(output["Operation"]);
    }
    if (output["Priority"] !== undefined) {
        contents.Priority = __strictParseInt32(output["Priority"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["CreationTime"] !== undefined) {
        contents.CreationTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreationTime"]));
    }
    if (output["TerminationDate"] !== undefined) {
        contents.TerminationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["TerminationDate"]));
    }
    if (output["ProgressSummary"] !== undefined) {
        contents.ProgressSummary = de_JobProgressSummary(output["ProgressSummary"], context);
    }
    return contents;
};
const de_JobListDescriptorList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobListDescriptor(entry, context);
    });
};
const de_JobManifest = (output, context) => {
    const contents = {};
    if (output["Spec"] !== undefined) {
        contents.Spec = de_JobManifestSpec(output["Spec"], context);
    }
    if (output["Location"] !== undefined) {
        contents.Location = de_JobManifestLocation(output["Location"], context);
    }
    return contents;
};
const de_JobManifestFieldList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_JobManifestGenerator = (output, context) => {
    if (output["S3JobManifestGenerator"] !== undefined) {
        return {
            S3JobManifestGenerator: de_S3JobManifestGenerator(output["S3JobManifestGenerator"], context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_JobManifestGeneratorFilter = (output, context) => {
    const contents = {};
    if (output["EligibleForReplication"] !== undefined) {
        contents.EligibleForReplication = __parseBoolean(output["EligibleForReplication"]);
    }
    if (output["CreatedAfter"] !== undefined) {
        contents.CreatedAfter = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedAfter"]));
    }
    if (output["CreatedBefore"] !== undefined) {
        contents.CreatedBefore = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedBefore"]));
    }
    if (output.ObjectReplicationStatuses === "") {
        contents.ObjectReplicationStatuses = [];
    }
    else if (output["ObjectReplicationStatuses"] !== undefined &&
        output["ObjectReplicationStatuses"]["member"] !== undefined) {
        contents.ObjectReplicationStatuses = de_ReplicationStatusFilterList(__getArrayIfSingleItem(output["ObjectReplicationStatuses"]["member"]), context);
    }
    if (output["KeyNameConstraint"] !== undefined) {
        contents.KeyNameConstraint = de_KeyNameConstraint(output["KeyNameConstraint"], context);
    }
    if (output["ObjectSizeGreaterThanBytes"] !== undefined) {
        contents.ObjectSizeGreaterThanBytes = __strictParseLong(output["ObjectSizeGreaterThanBytes"]);
    }
    if (output["ObjectSizeLessThanBytes"] !== undefined) {
        contents.ObjectSizeLessThanBytes = __strictParseLong(output["ObjectSizeLessThanBytes"]);
    }
    if (output.MatchAnyStorageClass === "") {
        contents.MatchAnyStorageClass = [];
    }
    else if (output["MatchAnyStorageClass"] !== undefined && output["MatchAnyStorageClass"]["member"] !== undefined) {
        contents.MatchAnyStorageClass = de_StorageClassList(__getArrayIfSingleItem(output["MatchAnyStorageClass"]["member"]), context);
    }
    return contents;
};
const de_JobManifestLocation = (output, context) => {
    const contents = {};
    if (output["ObjectArn"] !== undefined) {
        contents.ObjectArn = __expectString(output["ObjectArn"]);
    }
    if (output["ObjectVersionId"] !== undefined) {
        contents.ObjectVersionId = __expectString(output["ObjectVersionId"]);
    }
    if (output["ETag"] !== undefined) {
        contents.ETag = __expectString(output["ETag"]);
    }
    return contents;
};
const de_JobManifestSpec = (output, context) => {
    const contents = {};
    if (output["Format"] !== undefined) {
        contents.Format = __expectString(output["Format"]);
    }
    if (output.Fields === "") {
        contents.Fields = [];
    }
    else if (output["Fields"] !== undefined && output["Fields"]["member"] !== undefined) {
        contents.Fields = de_JobManifestFieldList(__getArrayIfSingleItem(output["Fields"]["member"]), context);
    }
    return contents;
};
const de_JobOperation = (output, context) => {
    const contents = {};
    if (output["LambdaInvoke"] !== undefined) {
        contents.LambdaInvoke = de_LambdaInvokeOperation(output["LambdaInvoke"], context);
    }
    if (output["S3PutObjectCopy"] !== undefined) {
        contents.S3PutObjectCopy = de_S3CopyObjectOperation(output["S3PutObjectCopy"], context);
    }
    if (output["S3PutObjectAcl"] !== undefined) {
        contents.S3PutObjectAcl = de_S3SetObjectAclOperation(output["S3PutObjectAcl"], context);
    }
    if (output["S3PutObjectTagging"] !== undefined) {
        contents.S3PutObjectTagging = de_S3SetObjectTaggingOperation(output["S3PutObjectTagging"], context);
    }
    if (output["S3DeleteObjectTagging"] !== undefined) {
        contents.S3DeleteObjectTagging = de_S3DeleteObjectTaggingOperation(output["S3DeleteObjectTagging"], context);
    }
    if (output["S3InitiateRestoreObject"] !== undefined) {
        contents.S3InitiateRestoreObject = de_S3InitiateRestoreObjectOperation(output["S3InitiateRestoreObject"], context);
    }
    if (output["S3PutObjectLegalHold"] !== undefined) {
        contents.S3PutObjectLegalHold = de_S3SetObjectLegalHoldOperation(output["S3PutObjectLegalHold"], context);
    }
    if (output["S3PutObjectRetention"] !== undefined) {
        contents.S3PutObjectRetention = de_S3SetObjectRetentionOperation(output["S3PutObjectRetention"], context);
    }
    if (output["S3ReplicateObject"] !== undefined) {
        contents.S3ReplicateObject = de_S3ReplicateObjectOperation(output["S3ReplicateObject"], context);
    }
    return contents;
};
const de_JobProgressSummary = (output, context) => {
    const contents = {};
    if (output["TotalNumberOfTasks"] !== undefined) {
        contents.TotalNumberOfTasks = __strictParseLong(output["TotalNumberOfTasks"]);
    }
    if (output["NumberOfTasksSucceeded"] !== undefined) {
        contents.NumberOfTasksSucceeded = __strictParseLong(output["NumberOfTasksSucceeded"]);
    }
    if (output["NumberOfTasksFailed"] !== undefined) {
        contents.NumberOfTasksFailed = __strictParseLong(output["NumberOfTasksFailed"]);
    }
    if (output["Timers"] !== undefined) {
        contents.Timers = de_JobTimers(output["Timers"], context);
    }
    return contents;
};
const de_JobReport = (output, context) => {
    const contents = {};
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    if (output["Format"] !== undefined) {
        contents.Format = __expectString(output["Format"]);
    }
    if (output["Enabled"] !== undefined) {
        contents.Enabled = __parseBoolean(output["Enabled"]);
    }
    if (output["Prefix"] !== undefined) {
        contents.Prefix = __expectString(output["Prefix"]);
    }
    if (output["ReportScope"] !== undefined) {
        contents.ReportScope = __expectString(output["ReportScope"]);
    }
    return contents;
};
const de_JobTimers = (output, context) => {
    const contents = {};
    if (output["ElapsedTimeInActiveSeconds"] !== undefined) {
        contents.ElapsedTimeInActiveSeconds = __strictParseLong(output["ElapsedTimeInActiveSeconds"]);
    }
    return contents;
};
const de_KeyNameConstraint = (output, context) => {
    const contents = {};
    if (output.MatchAnyPrefix === "") {
        contents.MatchAnyPrefix = [];
    }
    else if (output["MatchAnyPrefix"] !== undefined && output["MatchAnyPrefix"]["member"] !== undefined) {
        contents.MatchAnyPrefix = de_NonEmptyMaxLength1024StringList(__getArrayIfSingleItem(output["MatchAnyPrefix"]["member"]), context);
    }
    if (output.MatchAnySuffix === "") {
        contents.MatchAnySuffix = [];
    }
    else if (output["MatchAnySuffix"] !== undefined && output["MatchAnySuffix"]["member"] !== undefined) {
        contents.MatchAnySuffix = de_NonEmptyMaxLength1024StringList(__getArrayIfSingleItem(output["MatchAnySuffix"]["member"]), context);
    }
    if (output.MatchAnySubstring === "") {
        contents.MatchAnySubstring = [];
    }
    else if (output["MatchAnySubstring"] !== undefined && output["MatchAnySubstring"]["member"] !== undefined) {
        contents.MatchAnySubstring = de_NonEmptyMaxLength1024StringList(__getArrayIfSingleItem(output["MatchAnySubstring"]["member"]), context);
    }
    return contents;
};
const de_LambdaInvokeOperation = (output, context) => {
    const contents = {};
    if (output["FunctionArn"] !== undefined) {
        contents.FunctionArn = __expectString(output["FunctionArn"]);
    }
    if (output["InvocationSchemaVersion"] !== undefined) {
        contents.InvocationSchemaVersion = __expectString(output["InvocationSchemaVersion"]);
    }
    if (output.UserArguments === "") {
        contents.UserArguments = {};
    }
    else if (output["UserArguments"] !== undefined && output["UserArguments"]["entry"] !== undefined) {
        contents.UserArguments = de_UserArguments(__getArrayIfSingleItem(output["UserArguments"]["entry"]), context);
    }
    return contents;
};
const de_LifecycleExpiration = (output, context) => {
    const contents = {};
    if (output["Date"] !== undefined) {
        contents.Date = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Date"]));
    }
    if (output["Days"] !== undefined) {
        contents.Days = __strictParseInt32(output["Days"]);
    }
    if (output["ExpiredObjectDeleteMarker"] !== undefined) {
        contents.ExpiredObjectDeleteMarker = __parseBoolean(output["ExpiredObjectDeleteMarker"]);
    }
    return contents;
};
const de_LifecycleRule = (output, context) => {
    const contents = {};
    if (output["Expiration"] !== undefined) {
        contents.Expiration = de_LifecycleExpiration(output["Expiration"], context);
    }
    if (output["ID"] !== undefined) {
        contents.ID = __expectString(output["ID"]);
    }
    if (output["Filter"] !== undefined) {
        contents.Filter = de_LifecycleRuleFilter(output["Filter"], context);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output.Transitions === "") {
        contents.Transitions = [];
    }
    else if (output["Transitions"] !== undefined && output["Transitions"]["Transition"] !== undefined) {
        contents.Transitions = de_TransitionList(__getArrayIfSingleItem(output["Transitions"]["Transition"]), context);
    }
    if (output.NoncurrentVersionTransitions === "") {
        contents.NoncurrentVersionTransitions = [];
    }
    else if (output["NoncurrentVersionTransitions"] !== undefined &&
        output["NoncurrentVersionTransitions"]["NoncurrentVersionTransition"] !== undefined) {
        contents.NoncurrentVersionTransitions = de_NoncurrentVersionTransitionList(__getArrayIfSingleItem(output["NoncurrentVersionTransitions"]["NoncurrentVersionTransition"]), context);
    }
    if (output["NoncurrentVersionExpiration"] !== undefined) {
        contents.NoncurrentVersionExpiration = de_NoncurrentVersionExpiration(output["NoncurrentVersionExpiration"], context);
    }
    if (output["AbortIncompleteMultipartUpload"] !== undefined) {
        contents.AbortIncompleteMultipartUpload = de_AbortIncompleteMultipartUpload(output["AbortIncompleteMultipartUpload"], context);
    }
    return contents;
};
const de_LifecycleRuleAndOperator = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
        contents.Prefix = __expectString(output["Prefix"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_S3TagSet(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["ObjectSizeGreaterThan"] !== undefined) {
        contents.ObjectSizeGreaterThan = __strictParseLong(output["ObjectSizeGreaterThan"]);
    }
    if (output["ObjectSizeLessThan"] !== undefined) {
        contents.ObjectSizeLessThan = __strictParseLong(output["ObjectSizeLessThan"]);
    }
    return contents;
};
const de_LifecycleRuleFilter = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
        contents.Prefix = __expectString(output["Prefix"]);
    }
    if (output["Tag"] !== undefined) {
        contents.Tag = de_S3Tag(output["Tag"], context);
    }
    if (output["And"] !== undefined) {
        contents.And = de_LifecycleRuleAndOperator(output["And"], context);
    }
    if (output["ObjectSizeGreaterThan"] !== undefined) {
        contents.ObjectSizeGreaterThan = __strictParseLong(output["ObjectSizeGreaterThan"]);
    }
    if (output["ObjectSizeLessThan"] !== undefined) {
        contents.ObjectSizeLessThan = __strictParseLong(output["ObjectSizeLessThan"]);
    }
    return contents;
};
const de_LifecycleRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LifecycleRule(entry, context);
    });
};
const de_ListAccessGrantEntry = (output, context) => {
    const contents = {};
    if (output["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedAt"]));
    }
    if (output["AccessGrantId"] !== undefined) {
        contents.AccessGrantId = __expectString(output["AccessGrantId"]);
    }
    if (output["AccessGrantArn"] !== undefined) {
        contents.AccessGrantArn = __expectString(output["AccessGrantArn"]);
    }
    if (output["Grantee"] !== undefined) {
        contents.Grantee = de_Grantee(output["Grantee"], context);
    }
    if (output["Permission"] !== undefined) {
        contents.Permission = __expectString(output["Permission"]);
    }
    if (output["AccessGrantsLocationId"] !== undefined) {
        contents.AccessGrantsLocationId = __expectString(output["AccessGrantsLocationId"]);
    }
    if (output["AccessGrantsLocationConfiguration"] !== undefined) {
        contents.AccessGrantsLocationConfiguration = de_AccessGrantsLocationConfiguration(output["AccessGrantsLocationConfiguration"], context);
    }
    if (output["GrantScope"] !== undefined) {
        contents.GrantScope = __expectString(output["GrantScope"]);
    }
    if (output["ApplicationArn"] !== undefined) {
        contents.ApplicationArn = __expectString(output["ApplicationArn"]);
    }
    return contents;
};
const de_ListAccessGrantsInstanceEntry = (output, context) => {
    const contents = {};
    if (output["AccessGrantsInstanceId"] !== undefined) {
        contents.AccessGrantsInstanceId = __expectString(output["AccessGrantsInstanceId"]);
    }
    if (output["AccessGrantsInstanceArn"] !== undefined) {
        contents.AccessGrantsInstanceArn = __expectString(output["AccessGrantsInstanceArn"]);
    }
    if (output["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedAt"]));
    }
    if (output["IdentityCenterArn"] !== undefined) {
        contents.IdentityCenterArn = __expectString(output["IdentityCenterArn"]);
    }
    return contents;
};
const de_ListAccessGrantsLocationsEntry = (output, context) => {
    const contents = {};
    if (output["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedAt"]));
    }
    if (output["AccessGrantsLocationId"] !== undefined) {
        contents.AccessGrantsLocationId = __expectString(output["AccessGrantsLocationId"]);
    }
    if (output["AccessGrantsLocationArn"] !== undefined) {
        contents.AccessGrantsLocationArn = __expectString(output["AccessGrantsLocationArn"]);
    }
    if (output["LocationScope"] !== undefined) {
        contents.LocationScope = __expectString(output["LocationScope"]);
    }
    if (output["IAMRoleArn"] !== undefined) {
        contents.IAMRoleArn = __expectString(output["IAMRoleArn"]);
    }
    return contents;
};
const de_ListStorageLensConfigurationEntry = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["StorageLensArn"] !== undefined) {
        contents.StorageLensArn = __expectString(output["StorageLensArn"]);
    }
    if (output["HomeRegion"] !== undefined) {
        contents.HomeRegion = __expectString(output["HomeRegion"]);
    }
    if (output["IsEnabled"] !== undefined) {
        contents.IsEnabled = __parseBoolean(output["IsEnabled"]);
    }
    return contents;
};
const de_ListStorageLensGroupEntry = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["StorageLensGroupArn"] !== undefined) {
        contents.StorageLensGroupArn = __expectString(output["StorageLensGroupArn"]);
    }
    if (output["HomeRegion"] !== undefined) {
        contents.HomeRegion = __expectString(output["HomeRegion"]);
    }
    return contents;
};
const de_MatchAnyPrefix = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MatchAnySuffix = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MatchAnyTag = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_S3Tag(entry, context);
    });
};
const de_MatchObjectAge = (output, context) => {
    const contents = {};
    if (output["DaysGreaterThan"] !== undefined) {
        contents.DaysGreaterThan = __strictParseInt32(output["DaysGreaterThan"]);
    }
    if (output["DaysLessThan"] !== undefined) {
        contents.DaysLessThan = __strictParseInt32(output["DaysLessThan"]);
    }
    return contents;
};
const de_MatchObjectSize = (output, context) => {
    const contents = {};
    if (output["BytesGreaterThan"] !== undefined) {
        contents.BytesGreaterThan = __strictParseLong(output["BytesGreaterThan"]);
    }
    if (output["BytesLessThan"] !== undefined) {
        contents.BytesLessThan = __strictParseLong(output["BytesLessThan"]);
    }
    return contents;
};
const de_Metrics = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["EventThreshold"] !== undefined) {
        contents.EventThreshold = de_ReplicationTimeValue(output["EventThreshold"], context);
    }
    return contents;
};
const de_MultiRegionAccessPointPolicyDocument = (output, context) => {
    const contents = {};
    if (output["Established"] !== undefined) {
        contents.Established = de_EstablishedMultiRegionAccessPointPolicy(output["Established"], context);
    }
    if (output["Proposed"] !== undefined) {
        contents.Proposed = de_ProposedMultiRegionAccessPointPolicy(output["Proposed"], context);
    }
    return contents;
};
const de_MultiRegionAccessPointRegionalResponse = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["RequestStatus"] !== undefined) {
        contents.RequestStatus = __expectString(output["RequestStatus"]);
    }
    return contents;
};
const de_MultiRegionAccessPointRegionalResponseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MultiRegionAccessPointRegionalResponse(entry, context);
    });
};
const de_MultiRegionAccessPointReport = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Alias"] !== undefined) {
        contents.Alias = __expectString(output["Alias"]);
    }
    if (output["CreatedAt"] !== undefined) {
        contents.CreatedAt = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedAt"]));
    }
    if (output["PublicAccessBlock"] !== undefined) {
        contents.PublicAccessBlock = de_PublicAccessBlockConfiguration(output["PublicAccessBlock"], context);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output.Regions === "") {
        contents.Regions = [];
    }
    else if (output["Regions"] !== undefined && output["Regions"]["Region"] !== undefined) {
        contents.Regions = de_RegionReportList(__getArrayIfSingleItem(output["Regions"]["Region"]), context);
    }
    return contents;
};
const de_MultiRegionAccessPointReportList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MultiRegionAccessPointReport(entry, context);
    });
};
const de_MultiRegionAccessPointRoute = (output, context) => {
    const contents = {};
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    if (output["TrafficDialPercentage"] !== undefined) {
        contents.TrafficDialPercentage = __strictParseInt32(output["TrafficDialPercentage"]);
    }
    return contents;
};
const de_MultiRegionAccessPointsAsyncResponse = (output, context) => {
    const contents = {};
    if (output.Regions === "") {
        contents.Regions = [];
    }
    else if (output["Regions"] !== undefined && output["Regions"]["Region"] !== undefined) {
        contents.Regions = de_MultiRegionAccessPointRegionalResponseList(__getArrayIfSingleItem(output["Regions"]["Region"]), context);
    }
    return contents;
};
const de_NoncurrentVersionExpiration = (output, context) => {
    const contents = {};
    if (output["NoncurrentDays"] !== undefined) {
        contents.NoncurrentDays = __strictParseInt32(output["NoncurrentDays"]);
    }
    if (output["NewerNoncurrentVersions"] !== undefined) {
        contents.NewerNoncurrentVersions = __strictParseInt32(output["NewerNoncurrentVersions"]);
    }
    return contents;
};
const de_NoncurrentVersionTransition = (output, context) => {
    const contents = {};
    if (output["NoncurrentDays"] !== undefined) {
        contents.NoncurrentDays = __strictParseInt32(output["NoncurrentDays"]);
    }
    if (output["StorageClass"] !== undefined) {
        contents.StorageClass = __expectString(output["StorageClass"]);
    }
    return contents;
};
const de_NoncurrentVersionTransitionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NoncurrentVersionTransition(entry, context);
    });
};
const de_NonEmptyMaxLength1024StringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ObjectLambdaAccessPoint = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["ObjectLambdaAccessPointArn"] !== undefined) {
        contents.ObjectLambdaAccessPointArn = __expectString(output["ObjectLambdaAccessPointArn"]);
    }
    if (output["Alias"] !== undefined) {
        contents.Alias = de_ObjectLambdaAccessPointAlias(output["Alias"], context);
    }
    return contents;
};
const de_ObjectLambdaAccessPointAlias = (output, context) => {
    const contents = {};
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    return contents;
};
const de_ObjectLambdaAccessPointList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ObjectLambdaAccessPoint(entry, context);
    });
};
const de_ObjectLambdaAllowedFeaturesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ObjectLambdaConfiguration = (output, context) => {
    const contents = {};
    if (output["SupportingAccessPoint"] !== undefined) {
        contents.SupportingAccessPoint = __expectString(output["SupportingAccessPoint"]);
    }
    if (output["CloudWatchMetricsEnabled"] !== undefined) {
        contents.CloudWatchMetricsEnabled = __parseBoolean(output["CloudWatchMetricsEnabled"]);
    }
    if (output.AllowedFeatures === "") {
        contents.AllowedFeatures = [];
    }
    else if (output["AllowedFeatures"] !== undefined && output["AllowedFeatures"]["AllowedFeature"] !== undefined) {
        contents.AllowedFeatures = de_ObjectLambdaAllowedFeaturesList(__getArrayIfSingleItem(output["AllowedFeatures"]["AllowedFeature"]), context);
    }
    if (output.TransformationConfigurations === "") {
        contents.TransformationConfigurations = [];
    }
    else if (output["TransformationConfigurations"] !== undefined &&
        output["TransformationConfigurations"]["TransformationConfiguration"] !== undefined) {
        contents.TransformationConfigurations = de_ObjectLambdaTransformationConfigurationsList(__getArrayIfSingleItem(output["TransformationConfigurations"]["TransformationConfiguration"]), context);
    }
    return contents;
};
const de_ObjectLambdaContentTransformation = (output, context) => {
    if (output["AwsLambda"] !== undefined) {
        return {
            AwsLambda: de_AwsLambdaTransformation(output["AwsLambda"], context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_ObjectLambdaTransformationConfiguration = (output, context) => {
    const contents = {};
    if (output.Actions === "") {
        contents.Actions = [];
    }
    else if (output["Actions"] !== undefined && output["Actions"]["Action"] !== undefined) {
        contents.Actions = de_ObjectLambdaTransformationConfigurationActionsList(__getArrayIfSingleItem(output["Actions"]["Action"]), context);
    }
    if (output.ContentTransformation === "") {
    }
    else if (output["ContentTransformation"] !== undefined) {
        contents.ContentTransformation = de_ObjectLambdaContentTransformation(__expectUnion(output["ContentTransformation"]), context);
    }
    return contents;
};
const de_ObjectLambdaTransformationConfigurationActionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ObjectLambdaTransformationConfigurationsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ObjectLambdaTransformationConfiguration(entry, context);
    });
};
const de_PolicyStatus = (output, context) => {
    const contents = {};
    if (output["IsPublic"] !== undefined) {
        contents.IsPublic = __parseBoolean(output["IsPublic"]);
    }
    return contents;
};
const de_PrefixLevel = (output, context) => {
    const contents = {};
    if (output["StorageMetrics"] !== undefined) {
        contents.StorageMetrics = de_PrefixLevelStorageMetrics(output["StorageMetrics"], context);
    }
    return contents;
};
const de_PrefixLevelStorageMetrics = (output, context) => {
    const contents = {};
    if (output["IsEnabled"] !== undefined) {
        contents.IsEnabled = __parseBoolean(output["IsEnabled"]);
    }
    if (output["SelectionCriteria"] !== undefined) {
        contents.SelectionCriteria = de_SelectionCriteria(output["SelectionCriteria"], context);
    }
    return contents;
};
const de_ProposedMultiRegionAccessPointPolicy = (output, context) => {
    const contents = {};
    if (output["Policy"] !== undefined) {
        contents.Policy = __expectString(output["Policy"]);
    }
    return contents;
};
const de_PublicAccessBlockConfiguration = (output, context) => {
    const contents = {};
    if (output["BlockPublicAcls"] !== undefined) {
        contents.BlockPublicAcls = __parseBoolean(output["BlockPublicAcls"]);
    }
    if (output["IgnorePublicAcls"] !== undefined) {
        contents.IgnorePublicAcls = __parseBoolean(output["IgnorePublicAcls"]);
    }
    if (output["BlockPublicPolicy"] !== undefined) {
        contents.BlockPublicPolicy = __parseBoolean(output["BlockPublicPolicy"]);
    }
    if (output["RestrictPublicBuckets"] !== undefined) {
        contents.RestrictPublicBuckets = __parseBoolean(output["RestrictPublicBuckets"]);
    }
    return contents;
};
const de_PutMultiRegionAccessPointPolicyInput = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Policy"] !== undefined) {
        contents.Policy = __expectString(output["Policy"]);
    }
    return contents;
};
const de_Region = (output, context) => {
    const contents = {};
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    if (output["BucketAccountId"] !== undefined) {
        contents.BucketAccountId = __expectString(output["BucketAccountId"]);
    }
    return contents;
};
const de_RegionalBucket = (output, context) => {
    const contents = {};
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    if (output["BucketArn"] !== undefined) {
        contents.BucketArn = __expectString(output["BucketArn"]);
    }
    if (output["PublicAccessBlockEnabled"] !== undefined) {
        contents.PublicAccessBlockEnabled = __parseBoolean(output["PublicAccessBlockEnabled"]);
    }
    if (output["CreationDate"] !== undefined) {
        contents.CreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreationDate"]));
    }
    if (output["OutpostId"] !== undefined) {
        contents.OutpostId = __expectString(output["OutpostId"]);
    }
    return contents;
};
const de_RegionalBucketList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RegionalBucket(entry, context);
    });
};
const de_RegionCreationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Region(entry, context);
    });
};
const de_RegionReport = (output, context) => {
    const contents = {};
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    if (output["BucketAccountId"] !== undefined) {
        contents.BucketAccountId = __expectString(output["BucketAccountId"]);
    }
    return contents;
};
const de_RegionReportList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RegionReport(entry, context);
    });
};
const de_Regions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ReplicaModifications = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    return contents;
};
const de_ReplicationConfiguration = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = __expectString(output["Role"]);
    }
    if (output.Rules === "") {
        contents.Rules = [];
    }
    else if (output["Rules"] !== undefined && output["Rules"]["Rule"] !== undefined) {
        contents.Rules = de_ReplicationRules(__getArrayIfSingleItem(output["Rules"]["Rule"]), context);
    }
    return contents;
};
const de_ReplicationRule = (output, context) => {
    const contents = {};
    if (output["ID"] !== undefined) {
        contents.ID = __expectString(output["ID"]);
    }
    if (output["Priority"] !== undefined) {
        contents.Priority = __strictParseInt32(output["Priority"]);
    }
    if (output["Prefix"] !== undefined) {
        contents.Prefix = __expectString(output["Prefix"]);
    }
    if (output["Filter"] !== undefined) {
        contents.Filter = de_ReplicationRuleFilter(output["Filter"], context);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["SourceSelectionCriteria"] !== undefined) {
        contents.SourceSelectionCriteria = de_SourceSelectionCriteria(output["SourceSelectionCriteria"], context);
    }
    if (output["ExistingObjectReplication"] !== undefined) {
        contents.ExistingObjectReplication = de_ExistingObjectReplication(output["ExistingObjectReplication"], context);
    }
    if (output["Destination"] !== undefined) {
        contents.Destination = de_Destination(output["Destination"], context);
    }
    if (output["DeleteMarkerReplication"] !== undefined) {
        contents.DeleteMarkerReplication = de_DeleteMarkerReplication(output["DeleteMarkerReplication"], context);
    }
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    return contents;
};
const de_ReplicationRuleAndOperator = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
        contents.Prefix = __expectString(output["Prefix"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_S3TagSet(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_ReplicationRuleFilter = (output, context) => {
    const contents = {};
    if (output["Prefix"] !== undefined) {
        contents.Prefix = __expectString(output["Prefix"]);
    }
    if (output["Tag"] !== undefined) {
        contents.Tag = de_S3Tag(output["Tag"], context);
    }
    if (output["And"] !== undefined) {
        contents.And = de_ReplicationRuleAndOperator(output["And"], context);
    }
    return contents;
};
const de_ReplicationRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplicationRule(entry, context);
    });
};
const de_ReplicationStatusFilterList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ReplicationTime = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["Time"] !== undefined) {
        contents.Time = de_ReplicationTimeValue(output["Time"], context);
    }
    return contents;
};
const de_ReplicationTimeValue = (output, context) => {
    const contents = {};
    if (output["Minutes"] !== undefined) {
        contents.Minutes = __strictParseInt32(output["Minutes"]);
    }
    return contents;
};
const de_RouteList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MultiRegionAccessPointRoute(entry, context);
    });
};
const de_S3AccessControlList = (output, context) => {
    const contents = {};
    if (output["Owner"] !== undefined) {
        contents.Owner = de_S3ObjectOwner(output["Owner"], context);
    }
    if (output.Grants === "") {
        contents.Grants = [];
    }
    else if (output["Grants"] !== undefined && output["Grants"]["member"] !== undefined) {
        contents.Grants = de_S3GrantList(__getArrayIfSingleItem(output["Grants"]["member"]), context);
    }
    return contents;
};
const de_S3AccessControlPolicy = (output, context) => {
    const contents = {};
    if (output["AccessControlList"] !== undefined) {
        contents.AccessControlList = de_S3AccessControlList(output["AccessControlList"], context);
    }
    if (output["CannedAccessControlList"] !== undefined) {
        contents.CannedAccessControlList = __expectString(output["CannedAccessControlList"]);
    }
    return contents;
};
const de_S3BucketDestination = (output, context) => {
    const contents = {};
    if (output["Format"] !== undefined) {
        contents.Format = __expectString(output["Format"]);
    }
    if (output["OutputSchemaVersion"] !== undefined) {
        contents.OutputSchemaVersion = __expectString(output["OutputSchemaVersion"]);
    }
    if (output["AccountId"] !== undefined) {
        contents.AccountId = __expectString(output["AccountId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["Prefix"] !== undefined) {
        contents.Prefix = __expectString(output["Prefix"]);
    }
    if (output["Encryption"] !== undefined) {
        contents.Encryption = de_StorageLensDataExportEncryption(output["Encryption"], context);
    }
    return contents;
};
const de_S3CopyObjectOperation = (output, context) => {
    const contents = {};
    if (output["TargetResource"] !== undefined) {
        contents.TargetResource = __expectString(output["TargetResource"]);
    }
    if (output["CannedAccessControlList"] !== undefined) {
        contents.CannedAccessControlList = __expectString(output["CannedAccessControlList"]);
    }
    if (output.AccessControlGrants === "") {
        contents.AccessControlGrants = [];
    }
    else if (output["AccessControlGrants"] !== undefined && output["AccessControlGrants"]["member"] !== undefined) {
        contents.AccessControlGrants = de_S3GrantList(__getArrayIfSingleItem(output["AccessControlGrants"]["member"]), context);
    }
    if (output["MetadataDirective"] !== undefined) {
        contents.MetadataDirective = __expectString(output["MetadataDirective"]);
    }
    if (output["ModifiedSinceConstraint"] !== undefined) {
        contents.ModifiedSinceConstraint = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["ModifiedSinceConstraint"]));
    }
    if (output["NewObjectMetadata"] !== undefined) {
        contents.NewObjectMetadata = de_S3ObjectMetadata(output["NewObjectMetadata"], context);
    }
    if (output.NewObjectTagging === "") {
        contents.NewObjectTagging = [];
    }
    else if (output["NewObjectTagging"] !== undefined && output["NewObjectTagging"]["member"] !== undefined) {
        contents.NewObjectTagging = de_S3TagSet(__getArrayIfSingleItem(output["NewObjectTagging"]["member"]), context);
    }
    if (output["RedirectLocation"] !== undefined) {
        contents.RedirectLocation = __expectString(output["RedirectLocation"]);
    }
    if (output["RequesterPays"] !== undefined) {
        contents.RequesterPays = __parseBoolean(output["RequesterPays"]);
    }
    if (output["StorageClass"] !== undefined) {
        contents.StorageClass = __expectString(output["StorageClass"]);
    }
    if (output["UnModifiedSinceConstraint"] !== undefined) {
        contents.UnModifiedSinceConstraint = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["UnModifiedSinceConstraint"]));
    }
    if (output["SSEAwsKmsKeyId"] !== undefined) {
        contents.SSEAwsKmsKeyId = __expectString(output["SSEAwsKmsKeyId"]);
    }
    if (output["TargetKeyPrefix"] !== undefined) {
        contents.TargetKeyPrefix = __expectString(output["TargetKeyPrefix"]);
    }
    if (output["ObjectLockLegalHoldStatus"] !== undefined) {
        contents.ObjectLockLegalHoldStatus = __expectString(output["ObjectLockLegalHoldStatus"]);
    }
    if (output["ObjectLockMode"] !== undefined) {
        contents.ObjectLockMode = __expectString(output["ObjectLockMode"]);
    }
    if (output["ObjectLockRetainUntilDate"] !== undefined) {
        contents.ObjectLockRetainUntilDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["ObjectLockRetainUntilDate"]));
    }
    if (output["BucketKeyEnabled"] !== undefined) {
        contents.BucketKeyEnabled = __parseBoolean(output["BucketKeyEnabled"]);
    }
    if (output["ChecksumAlgorithm"] !== undefined) {
        contents.ChecksumAlgorithm = __expectString(output["ChecksumAlgorithm"]);
    }
    return contents;
};
const de_S3DeleteObjectTaggingOperation = (output, context) => {
    const contents = {};
    return contents;
};
const de_S3GeneratedManifestDescriptor = (output, context) => {
    const contents = {};
    if (output["Format"] !== undefined) {
        contents.Format = __expectString(output["Format"]);
    }
    if (output["Location"] !== undefined) {
        contents.Location = de_JobManifestLocation(output["Location"], context);
    }
    return contents;
};
const de_S3Grant = (output, context) => {
    const contents = {};
    if (output["Grantee"] !== undefined) {
        contents.Grantee = de_S3Grantee(output["Grantee"], context);
    }
    if (output["Permission"] !== undefined) {
        contents.Permission = __expectString(output["Permission"]);
    }
    return contents;
};
const de_S3Grantee = (output, context) => {
    const contents = {};
    if (output["TypeIdentifier"] !== undefined) {
        contents.TypeIdentifier = __expectString(output["TypeIdentifier"]);
    }
    if (output["Identifier"] !== undefined) {
        contents.Identifier = __expectString(output["Identifier"]);
    }
    if (output["DisplayName"] !== undefined) {
        contents.DisplayName = __expectString(output["DisplayName"]);
    }
    return contents;
};
const de_S3GrantList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_S3Grant(entry, context);
    });
};
const de_S3InitiateRestoreObjectOperation = (output, context) => {
    const contents = {};
    if (output["ExpirationInDays"] !== undefined) {
        contents.ExpirationInDays = __strictParseInt32(output["ExpirationInDays"]);
    }
    if (output["GlacierJobTier"] !== undefined) {
        contents.GlacierJobTier = __expectString(output["GlacierJobTier"]);
    }
    return contents;
};
const de_S3JobManifestGenerator = (output, context) => {
    const contents = {};
    if (output["ExpectedBucketOwner"] !== undefined) {
        contents.ExpectedBucketOwner = __expectString(output["ExpectedBucketOwner"]);
    }
    if (output["SourceBucket"] !== undefined) {
        contents.SourceBucket = __expectString(output["SourceBucket"]);
    }
    if (output["ManifestOutputLocation"] !== undefined) {
        contents.ManifestOutputLocation = de_S3ManifestOutputLocation(output["ManifestOutputLocation"], context);
    }
    if (output["Filter"] !== undefined) {
        contents.Filter = de_JobManifestGeneratorFilter(output["Filter"], context);
    }
    if (output["EnableManifestOutput"] !== undefined) {
        contents.EnableManifestOutput = __parseBoolean(output["EnableManifestOutput"]);
    }
    return contents;
};
const de_S3ManifestOutputLocation = (output, context) => {
    const contents = {};
    if (output["ExpectedManifestBucketOwner"] !== undefined) {
        contents.ExpectedManifestBucketOwner = __expectString(output["ExpectedManifestBucketOwner"]);
    }
    if (output["Bucket"] !== undefined) {
        contents.Bucket = __expectString(output["Bucket"]);
    }
    if (output["ManifestPrefix"] !== undefined) {
        contents.ManifestPrefix = __expectString(output["ManifestPrefix"]);
    }
    if (output["ManifestEncryption"] !== undefined) {
        contents.ManifestEncryption = de_GeneratedManifestEncryption(output["ManifestEncryption"], context);
    }
    if (output["ManifestFormat"] !== undefined) {
        contents.ManifestFormat = __expectString(output["ManifestFormat"]);
    }
    return contents;
};
const de_S3ObjectLockLegalHold = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    return contents;
};
const de_S3ObjectMetadata = (output, context) => {
    const contents = {};
    if (output["CacheControl"] !== undefined) {
        contents.CacheControl = __expectString(output["CacheControl"]);
    }
    if (output["ContentDisposition"] !== undefined) {
        contents.ContentDisposition = __expectString(output["ContentDisposition"]);
    }
    if (output["ContentEncoding"] !== undefined) {
        contents.ContentEncoding = __expectString(output["ContentEncoding"]);
    }
    if (output["ContentLanguage"] !== undefined) {
        contents.ContentLanguage = __expectString(output["ContentLanguage"]);
    }
    if (output.UserMetadata === "") {
        contents.UserMetadata = {};
    }
    else if (output["UserMetadata"] !== undefined && output["UserMetadata"]["entry"] !== undefined) {
        contents.UserMetadata = de_S3UserMetadata(__getArrayIfSingleItem(output["UserMetadata"]["entry"]), context);
    }
    if (output["ContentLength"] !== undefined) {
        contents.ContentLength = __strictParseLong(output["ContentLength"]);
    }
    if (output["ContentMD5"] !== undefined) {
        contents.ContentMD5 = __expectString(output["ContentMD5"]);
    }
    if (output["ContentType"] !== undefined) {
        contents.ContentType = __expectString(output["ContentType"]);
    }
    if (output["HttpExpiresDate"] !== undefined) {
        contents.HttpExpiresDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["HttpExpiresDate"]));
    }
    if (output["RequesterCharged"] !== undefined) {
        contents.RequesterCharged = __parseBoolean(output["RequesterCharged"]);
    }
    if (output["SSEAlgorithm"] !== undefined) {
        contents.SSEAlgorithm = __expectString(output["SSEAlgorithm"]);
    }
    return contents;
};
const de_S3ObjectOwner = (output, context) => {
    const contents = {};
    if (output["ID"] !== undefined) {
        contents.ID = __expectString(output["ID"]);
    }
    if (output["DisplayName"] !== undefined) {
        contents.DisplayName = __expectString(output["DisplayName"]);
    }
    return contents;
};
const de_S3ReplicateObjectOperation = (output, context) => {
    const contents = {};
    return contents;
};
const de_S3Retention = (output, context) => {
    const contents = {};
    if (output["RetainUntilDate"] !== undefined) {
        contents.RetainUntilDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["RetainUntilDate"]));
    }
    if (output["Mode"] !== undefined) {
        contents.Mode = __expectString(output["Mode"]);
    }
    return contents;
};
const de_S3SetObjectAclOperation = (output, context) => {
    const contents = {};
    if (output["AccessControlPolicy"] !== undefined) {
        contents.AccessControlPolicy = de_S3AccessControlPolicy(output["AccessControlPolicy"], context);
    }
    return contents;
};
const de_S3SetObjectLegalHoldOperation = (output, context) => {
    const contents = {};
    if (output["LegalHold"] !== undefined) {
        contents.LegalHold = de_S3ObjectLockLegalHold(output["LegalHold"], context);
    }
    return contents;
};
const de_S3SetObjectRetentionOperation = (output, context) => {
    const contents = {};
    if (output["BypassGovernanceRetention"] !== undefined) {
        contents.BypassGovernanceRetention = __parseBoolean(output["BypassGovernanceRetention"]);
    }
    if (output["Retention"] !== undefined) {
        contents.Retention = de_S3Retention(output["Retention"], context);
    }
    return contents;
};
const de_S3SetObjectTaggingOperation = (output, context) => {
    const contents = {};
    if (output.TagSet === "") {
        contents.TagSet = [];
    }
    else if (output["TagSet"] !== undefined && output["TagSet"]["member"] !== undefined) {
        contents.TagSet = de_S3TagSet(__getArrayIfSingleItem(output["TagSet"]["member"]), context);
    }
    return contents;
};
const de_S3Tag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = __expectString(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_S3TagSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_S3Tag(entry, context);
    });
};
const de_S3UserMetadata = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_SelectionCriteria = (output, context) => {
    const contents = {};
    if (output["Delimiter"] !== undefined) {
        contents.Delimiter = __expectString(output["Delimiter"]);
    }
    if (output["MaxDepth"] !== undefined) {
        contents.MaxDepth = __strictParseInt32(output["MaxDepth"]);
    }
    if (output["MinStorageBytesPercentage"] !== undefined) {
        contents.MinStorageBytesPercentage = __strictParseFloat(output["MinStorageBytesPercentage"]);
    }
    return contents;
};
const de_SourceSelectionCriteria = (output, context) => {
    const contents = {};
    if (output["SseKmsEncryptedObjects"] !== undefined) {
        contents.SseKmsEncryptedObjects = de_SseKmsEncryptedObjects(output["SseKmsEncryptedObjects"], context);
    }
    if (output["ReplicaModifications"] !== undefined) {
        contents.ReplicaModifications = de_ReplicaModifications(output["ReplicaModifications"], context);
    }
    return contents;
};
const de_SSEKMS = (output, context) => {
    const contents = {};
    if (output["KeyId"] !== undefined) {
        contents.KeyId = __expectString(output["KeyId"]);
    }
    return contents;
};
const de_SseKmsEncryptedObjects = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    return contents;
};
const de_SSEKMSEncryption = (output, context) => {
    const contents = {};
    if (output["KeyId"] !== undefined) {
        contents.KeyId = __expectString(output["KeyId"]);
    }
    return contents;
};
const de_SSES3 = (output, context) => {
    const contents = {};
    return contents;
};
const de_SSES3Encryption = (output, context) => {
    const contents = {};
    return contents;
};
const de_StorageClassList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_StorageLensAwsOrg = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    return contents;
};
const de_StorageLensConfiguration = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["AccountLevel"] !== undefined) {
        contents.AccountLevel = de_AccountLevel(output["AccountLevel"], context);
    }
    if (output["Include"] !== undefined) {
        contents.Include = de_Include(output["Include"], context);
    }
    if (output["Exclude"] !== undefined) {
        contents.Exclude = de__Exclude(output["Exclude"], context);
    }
    if (output["DataExport"] !== undefined) {
        contents.DataExport = de_StorageLensDataExport(output["DataExport"], context);
    }
    if (output["IsEnabled"] !== undefined) {
        contents.IsEnabled = __parseBoolean(output["IsEnabled"]);
    }
    if (output["AwsOrg"] !== undefined) {
        contents.AwsOrg = de_StorageLensAwsOrg(output["AwsOrg"], context);
    }
    if (output["StorageLensArn"] !== undefined) {
        contents.StorageLensArn = __expectString(output["StorageLensArn"]);
    }
    return contents;
};
const de_StorageLensConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListStorageLensConfigurationEntry(entry, context);
    });
};
const de_StorageLensDataExport = (output, context) => {
    const contents = {};
    if (output["S3BucketDestination"] !== undefined) {
        contents.S3BucketDestination = de_S3BucketDestination(output["S3BucketDestination"], context);
    }
    if (output["CloudWatchMetrics"] !== undefined) {
        contents.CloudWatchMetrics = de_CloudWatchMetrics(output["CloudWatchMetrics"], context);
    }
    return contents;
};
const de_StorageLensDataExportEncryption = (output, context) => {
    const contents = {};
    if (output["SSE-S3"] !== undefined) {
        contents.SSES3 = de_SSES3(output["SSE-S3"], context);
    }
    if (output["SSE-KMS"] !== undefined) {
        contents.SSEKMS = de_SSEKMS(output["SSE-KMS"], context);
    }
    return contents;
};
const de_StorageLensGroup = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Filter"] !== undefined) {
        contents.Filter = de_StorageLensGroupFilter(output["Filter"], context);
    }
    if (output["StorageLensGroupArn"] !== undefined) {
        contents.StorageLensGroupArn = __expectString(output["StorageLensGroupArn"]);
    }
    return contents;
};
const de_StorageLensGroupAndOperator = (output, context) => {
    const contents = {};
    if (output.MatchAnyPrefix === "") {
        contents.MatchAnyPrefix = [];
    }
    else if (output["MatchAnyPrefix"] !== undefined && output["MatchAnyPrefix"]["Prefix"] !== undefined) {
        contents.MatchAnyPrefix = de_MatchAnyPrefix(__getArrayIfSingleItem(output["MatchAnyPrefix"]["Prefix"]), context);
    }
    if (output.MatchAnySuffix === "") {
        contents.MatchAnySuffix = [];
    }
    else if (output["MatchAnySuffix"] !== undefined && output["MatchAnySuffix"]["Suffix"] !== undefined) {
        contents.MatchAnySuffix = de_MatchAnySuffix(__getArrayIfSingleItem(output["MatchAnySuffix"]["Suffix"]), context);
    }
    if (output.MatchAnyTag === "") {
        contents.MatchAnyTag = [];
    }
    else if (output["MatchAnyTag"] !== undefined && output["MatchAnyTag"]["Tag"] !== undefined) {
        contents.MatchAnyTag = de_MatchAnyTag(__getArrayIfSingleItem(output["MatchAnyTag"]["Tag"]), context);
    }
    if (output["MatchObjectAge"] !== undefined) {
        contents.MatchObjectAge = de_MatchObjectAge(output["MatchObjectAge"], context);
    }
    if (output["MatchObjectSize"] !== undefined) {
        contents.MatchObjectSize = de_MatchObjectSize(output["MatchObjectSize"], context);
    }
    return contents;
};
const de_StorageLensGroupFilter = (output, context) => {
    const contents = {};
    if (output.MatchAnyPrefix === "") {
        contents.MatchAnyPrefix = [];
    }
    else if (output["MatchAnyPrefix"] !== undefined && output["MatchAnyPrefix"]["Prefix"] !== undefined) {
        contents.MatchAnyPrefix = de_MatchAnyPrefix(__getArrayIfSingleItem(output["MatchAnyPrefix"]["Prefix"]), context);
    }
    if (output.MatchAnySuffix === "") {
        contents.MatchAnySuffix = [];
    }
    else if (output["MatchAnySuffix"] !== undefined && output["MatchAnySuffix"]["Suffix"] !== undefined) {
        contents.MatchAnySuffix = de_MatchAnySuffix(__getArrayIfSingleItem(output["MatchAnySuffix"]["Suffix"]), context);
    }
    if (output.MatchAnyTag === "") {
        contents.MatchAnyTag = [];
    }
    else if (output["MatchAnyTag"] !== undefined && output["MatchAnyTag"]["Tag"] !== undefined) {
        contents.MatchAnyTag = de_MatchAnyTag(__getArrayIfSingleItem(output["MatchAnyTag"]["Tag"]), context);
    }
    if (output["MatchObjectAge"] !== undefined) {
        contents.MatchObjectAge = de_MatchObjectAge(output["MatchObjectAge"], context);
    }
    if (output["MatchObjectSize"] !== undefined) {
        contents.MatchObjectSize = de_MatchObjectSize(output["MatchObjectSize"], context);
    }
    if (output["And"] !== undefined) {
        contents.And = de_StorageLensGroupAndOperator(output["And"], context);
    }
    if (output["Or"] !== undefined) {
        contents.Or = de_StorageLensGroupOrOperator(output["Or"], context);
    }
    return contents;
};
const de_StorageLensGroupLevel = (output, context) => {
    const contents = {};
    if (output["SelectionCriteria"] !== undefined) {
        contents.SelectionCriteria = de_StorageLensGroupLevelSelectionCriteria(output["SelectionCriteria"], context);
    }
    return contents;
};
const de_StorageLensGroupLevelExclude = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_StorageLensGroupLevelInclude = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_StorageLensGroupLevelSelectionCriteria = (output, context) => {
    const contents = {};
    if (output.Include === "") {
        contents.Include = [];
    }
    else if (output["Include"] !== undefined && output["Include"]["Arn"] !== undefined) {
        contents.Include = de_StorageLensGroupLevelInclude(__getArrayIfSingleItem(output["Include"]["Arn"]), context);
    }
    if (output.Exclude === "") {
        contents.Exclude = [];
    }
    else if (output["Exclude"] !== undefined && output["Exclude"]["Arn"] !== undefined) {
        contents.Exclude = de_StorageLensGroupLevelExclude(__getArrayIfSingleItem(output["Exclude"]["Arn"]), context);
    }
    return contents;
};
const de_StorageLensGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListStorageLensGroupEntry(entry, context);
    });
};
const de_StorageLensGroupOrOperator = (output, context) => {
    const contents = {};
    if (output.MatchAnyPrefix === "") {
        contents.MatchAnyPrefix = [];
    }
    else if (output["MatchAnyPrefix"] !== undefined && output["MatchAnyPrefix"]["Prefix"] !== undefined) {
        contents.MatchAnyPrefix = de_MatchAnyPrefix(__getArrayIfSingleItem(output["MatchAnyPrefix"]["Prefix"]), context);
    }
    if (output.MatchAnySuffix === "") {
        contents.MatchAnySuffix = [];
    }
    else if (output["MatchAnySuffix"] !== undefined && output["MatchAnySuffix"]["Suffix"] !== undefined) {
        contents.MatchAnySuffix = de_MatchAnySuffix(__getArrayIfSingleItem(output["MatchAnySuffix"]["Suffix"]), context);
    }
    if (output.MatchAnyTag === "") {
        contents.MatchAnyTag = [];
    }
    else if (output["MatchAnyTag"] !== undefined && output["MatchAnyTag"]["Tag"] !== undefined) {
        contents.MatchAnyTag = de_MatchAnyTag(__getArrayIfSingleItem(output["MatchAnyTag"]["Tag"]), context);
    }
    if (output["MatchObjectAge"] !== undefined) {
        contents.MatchObjectAge = de_MatchObjectAge(output["MatchObjectAge"], context);
    }
    if (output["MatchObjectSize"] !== undefined) {
        contents.MatchObjectSize = de_MatchObjectSize(output["MatchObjectSize"], context);
    }
    return contents;
};
const de_StorageLensTag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = __expectString(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_StorageLensTags = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StorageLensTag(entry, context);
    });
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = __expectString(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_Transition = (output, context) => {
    const contents = {};
    if (output["Date"] !== undefined) {
        contents.Date = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Date"]));
    }
    if (output["Days"] !== undefined) {
        contents.Days = __strictParseInt32(output["Days"]);
    }
    if (output["StorageClass"] !== undefined) {
        contents.StorageClass = __expectString(output["StorageClass"]);
    }
    return contents;
};
const de_TransitionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Transition(entry, context);
    });
};
const de_UserArguments = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_VpcConfiguration = (output, context) => {
    const contents = {};
    if (output["VpcId"] !== undefined) {
        contents.VpcId = __expectString(output["VpcId"]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
